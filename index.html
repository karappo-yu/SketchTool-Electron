<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>限时速写工具</title>
    <style>
        /* CSS Variables for theming */
        :root {
            /* Dark Theme Defaults */
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-mid: #16213e;
            --bg-gradient-end: #0f3460;
            --text-color: #e0e0e0;
            --glass-bg-color: rgba(40, 44, 52, 0.6);
            --glass-border-color: rgba(255, 255, 255, 0.18);
            --button-primary-start: #0f3460;
            --button-primary-end: #16213e;
            --button-toggle-bg: rgba(255, 255, 255, 0.08);
            --button-toggle-hover-bg: rgba(255, 255, 255, 0.15);
            --button-toggle-active-start: #28a745;
            --button-toggle-active-end: #218838;
            --button-nav-bg: rgba(255, 255, 255, 0.35);
            --button-nav-color: rgba(255, 255, 255, 0.95);
            --button-nav-hover-bg: rgba(255, 255, 255, 0.5);
            --input-bg: rgba(255, 255, 255, 0.05);
            --input-border: rgba(255, 255, 255, 0.2);
            --info-text-color: #a0a0a0;
            --default-preview-bg: #1a1a2e;
            --alert-bg: rgba(40, 44, 52, 0.9);
            --alert-border: 1px solid rgba(255, 255, 255, 0.18);
            --alert-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            --mark-info-bg: rgba(0, 0, 0, 0.7);
            --mark-info-text-color: #ffffff; /* Explicitly white for dark theme */
            --delete-mark-color: #dc3545;
            --folder-completed-bg: #28a745; /* Green for completed folders */
        }

        body.light-theme {
            /* Light Theme Overrides */
            --bg-gradient-start: #f0f2f5;
            --bg-gradient-mid: #e9ecef;
            --bg-gradient-end: #dee2e6;
            --text-color: #333333;
            --glass-bg-color: rgba(255, 255, 255, 0.8);
            --glass-border-color: rgba(0, 0, 0, 0.1);
            --button-primary-start: #4a90e2; /* Sky blue */
            --button-primary-end: #61a9f5;
            --button-toggle-bg: rgba(0, 0, 0, 0.05);
            --button-toggle-hover-bg: rgba(0, 0, 0, 0.1);
            --button-toggle-active-start: #28a745;
            --button-toggle-active-end: #218838;
            --button-nav-bg: rgba(0, 0, 0, 0.2);
            --button-nav-color: rgba(0, 0, 0, 0.85);
            --button-nav-hover-bg: rgba(0, 0, 0, 0.35);
            --input-bg: rgba(0, 0, 0, 0.03);
            --input-border: rgba(0, 0, 0, 0.15);
            --info-text-color: #666666;
            --default-preview-bg: #f8f9fa; /* Lighter preview background */
            --alert-bg: rgba(255, 255, 255, 0.95);
            --alert-border: 1px solid rgba(0, 0, 0, 0.1);
            --alert-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            --mark-info-bg: rgba(0, 0, 0, 0.7); /* Darker background for contrast in light theme */
            --mark-info-text-color: #ffffff; /* Explicitly white for light theme */
            --delete-mark-color: #dc3545;
            --folder-completed-bg: #28a745; /* Green for completed folders */
        }

        /* CSS Reset 和全局样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* REMOVE background properties from body here, they are moved to #dynamic-background-layer */
            background: none; 
            color: var(--text-color);
            overflow: hidden;
            /* transition moved to #dynamic-background-layer */

            /* Electron 拖动区域：将整个 body 设置为可拖动 */
            -webkit-app-region: drag;
        }

        /* New: Dedicated layer for dynamic preview backgrounds */
        #dynamic-background-layer {
            position: fixed; /* Fixed to viewport */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0; /* Behind everything else */
            /* Apply background transitions here */
            transition: background-color 0.8s ease, background-image 0.8s ease, filter 0.5s ease;
            /* Ensure it's not draggable by default */
            -webkit-app-region: no-drag;
        }

        /* New: Grayscale effect applied ONLY to the background layer */
        #dynamic-background-layer.grayscale-active-bg {
            filter: grayscale(100%);
        }


        /* 玻璃拟态效果基础样式 */
        .glassmorphism {
            background: var(--glass-bg-color);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border-color);
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); /* Shadow is intentionally not themed directly by variable for consistency */
            padding: 20px;
            margin: 10px;
            
            /* 玻璃拟态元素本身不能拖动，确保内部可拖动区域正常工作 */
            -webkit-app-region: no-drag;
        }

        /* The rest of the CSS using variables */
        #app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 1; /* CRITICAL: Must be higher than #dynamic-background-layer */
            background-color: transparent; /* Ensure app-container itself is transparent to show background layer */
            
            /* app-container 作为主内容区域，也应设为可拖动 */
            -webkit-app-region: drag;
        }

        #controls-menu {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 90%;
            width: 400px;
        }

        #controls-menu.hidden {
            display: none;
        }

        #folder-browser-view {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 90%;
            width: 800px;
            height: 80vh;
            align-items: center;
            justify-content: flex-start;
            overflow-y: hidden;
        }
        #folder-browser-view.hidden {
            display: none;
        }

        /* New: Folder browser header container */
        .folder-browser-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 0 10px; /* Consistent padding */
            margin-bottom: 10px; /* Space from content below */
            flex-wrap: wrap; /* Allow wrapping by default now */
            gap: 10px; /* Consistent gap between items */
        }

        .folder-browser-header h1 {
            margin: 0; /* Remove default margins */
            font-size: 1.8em;
            color: var(--text-color);
            flex-shrink: 0; /* Prevent shrinking */
            white-space: nowrap; /* Prevent text wrapping within h1 */
        }

        .folder-browser-header #current-library-path {
            margin: 0; /* Adjusted: No fixed margin-left/right, use gap instead */
            font-size: 0.9em;
            color: var(--info-text-color);
            text-align: left; /* Align text left */
            flex-grow: 1; /* Allow path to take available space */
            white-space: nowrap; /* Prevent wrapping of path text */
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0; /* Allow text to shrink if necessary */
        }
        .folder-browser-header-buttons {
            display: flex;
            gap: 8px; /* Gap between buttons */
        }

        .folder-browser-header #goUpFolderButton,
        .folder-browser-header #libraryFilterMarkedToggle {
            margin: 0; /* Remove default margins */
            padding: 8px 15px; /* Adjust button padding */
            font-size: 0.9em;
            flex-shrink: 0; /* Prevent shrinking */
            border-radius: 8px; /* Ensure consistent border-radius for buttons */
        }
        /* New: Styles for library filter button icon */
        .folder-browser-header #libraryFilterMarkedToggle .mark-icon {
            font-size: 1.8em; /* Match markStarButton size */
            line-height: 1;
            display: block;
            /* Color and background are handled by .toggle and .active classes */
        }


        .info-message {
            font-size: 1.1em;
            color: var(--info-text-color);
            text-align: center;
            margin-top: 50px;
            width: 100%;
        }
        
        #thumbnails-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            padding: 10px;
            width: 100%;
            flex-grow: 1;
            overflow-y: auto;
            justify-content: center;
            align-content: flex-start;
        }

        .thumbnail-item {
            background: rgba(255, 255, 255, 0.05); /* This can stay fixed for contrast or be themed */
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            height: 160px;
            text-decoration: none;
            color: inherit;
            position: relative; /* For positioning mark info */
        }

        .thumbnail-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.1); /* This can stay fixed or be themed */
        }

        .thumbnail-item img {
            max-width: 100%;
            max-height: 100px;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .thumbnail-item .folder-icon {
            font-size: 60px;
            margin-bottom: 10px;
        }

        .thumbnail-label {
            font-size: 0.8em;
            color: var(--info-text-color);
            margin-top: 8px;
            text-align: center;
            word-break: break-all;
            white-space: normal;
            max-height: 2.4em;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
        }

        /* New: Styles for mark information on thumbnail */
        .thumbnail-mark-info {
            position: absolute;
            top: 5px;
            left: 5px;
            background: var(--mark-info-bg);
            color: var(--mark-info-text-color); /* Use the new variable for consistent white text */
            font-size: 0.75em;
            padding: 3px 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            user-select: none;
            pointer-events: auto; /* Allow interaction */
            z-index: 1;
        }

        .delete-mark-button {
            background: none;
            border: none;
            color: var(--delete-mark-color);
            font-size: 1.2em;
            cursor: pointer;
            padding: 0 2px;
            line-height: 1;
            font-weight: bold;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .delete-mark-button:hover {
            color: #ff6b6b; /* Lighter red on hover */
            transform: scale(1.2);
        }
        body.light-theme .delete-mark-button {
            color: #dc3545; /* Darker red for light theme */
        }
        body.light-theme .delete-mark-button:hover {
            color: #ff6b6b;
        }

        /* New: Folder completed mark style */
        .thumbnail-folder-completed-info {
            position: absolute;
            top: 5px;
            right: 5px; /* Position on the right for folders */
            background: var(--folder-completed-bg); /* Use green color */
            color: #ffffff; /* White text for contrast */
            font-size: 0.75em;
            padding: 3px 6px;
            border-radius: 4px;
            user-select: none;
            pointer-events: none; /* Make it non-interactive */
            z-index: 1;
            font-weight: bold;
        }


        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 0.9em;
            color: var(--info-text-color);
        }
        
        .custom-input-like-button {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            cursor: pointer;
            text-align: center; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: border-color 0.3s, background-color 0.3s, color 0.3s;
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        .custom-input-like-button:hover {
            border-color: var(--button-primary-start); /* Using primary button start color for hover border */
            background-color: var(--button-toggle-hover-bg); /* Using toggle hover bg for consistency */
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            outline: none;
            transition: border-color 0.3s, background-color 0.3s, color 0.3s;
            /* 防止输入框成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            border-color: var(--button-primary-start);
            background-color: var(--button-toggle-hover-bg);
        }
        input[type="number"]:disabled {
            background-color: var(--button-toggle-bg); /* Slightly different background for disabled */
            color: var(--info-text-color); /* Lighter text for disabled */
            cursor: not-allowed;
        }


        .buttons-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            outline: none;
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease;
            color: var(--text-color);
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative; /* Needed for tooltips */
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        button.primary {
            background: linear-gradient(135deg, var(--button-primary-start), var(--button-primary-end));
        }

        button.primary:hover {
            background: linear-gradient(135deg, var(--button-primary-end), var(--button-primary-start)); /* Reverse gradient on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        button.toggle {
            background: var(--button-toggle-bg);
            box-shadow: none;
            padding: 8px 15px;
        }

        button.toggle.active {
            background: linear-gradient(135deg, var(--button-toggle-active-start), var(--button-toggle-active-end));
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.4);
        }

        button.toggle:not(.active):hover {
            background: var(--button-toggle-hover-bg);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }

        /* Tooltip base styles for all buttons that use data-tooltip */
        button[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }
        button[data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
        }
        button[data-tooltip]::before { /* Tooltip arrow */
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid rgba(0, 0, 0, 0.7); /* Pointing up */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }
        button[data-tooltip]:hover::before {
            opacity: 1;
            visibility: visible;
        }

        /* Positioning for main menu top-right buttons tooltips */
        #top-right-menu-buttons button[data-tooltip]::after {
            top: 100%; /* Position below the button */
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px; /* Space from the button */
        }
        #top-right-menu-buttons button[data-tooltip]::before {
            top: 100%; /* Position below the button */
            left: 50%;
            transform: translateX(-50%) translateY(-8px); /* Adjust for arrow position */
        }
        /* Positioning for overlay buttons tooltips */
        #overlay-controls button[data-tooltip]::after {
            top: 100%; /* Position below the button */
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px; /* Space from the button */
        }
        #overlay-controls button[data-tooltip]::before {
            top: 100%; /* Position below the button */
            left: 50%;
            transform: translateX(-50%) translateY(-8px); /* Adjust for arrow position */
        }

        /* Positioning for startButton tooltip */
        #startButton[data-tooltip]::after {
            bottom: 100%; /* Position above the button */
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 10px; /* Space from the button */
        }
        #startButton[data-tooltip]::before {
            bottom: 100%; /* Position above the button */
            left: 50%;
            transform: translateX(-50%) translateY(8px); /* Adjust for arrow position */
            border-top: 6px solid rgba(0, 0, 0, 0.7); /* Pointing down */
            border-bottom: none; /* No bottom border */
        }


        #image-display-area {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            overflow: hidden;
        }

        #image-display-area.hidden {
            display: none;
        }

        #current-image {
            max-width: 100%;
            max-height: 100%;
            width: auto; /* Allow natural width based on aspect ratio */
            height: auto; /* Allow natural height based on aspect ratio */
            object-fit: contain; /* This is key for fitting without cropping */
            transition: filter 0.5s ease, transform 0.5s ease;
            user-select: none;
            pointer-events: none;
        }


        #countdown {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 3em;
            font-weight: bold;
            color: var(--text-color); /* Themed text color */
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 5;
            pointer-events: none;
        }

        #grid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #grid-canvas.active {
            opacity: 1;
        }

        /* Image effects */
        .mirror-effect {
            transform: scaleX(-1);
        }

        .grayscale-effect {
            filter: grayscale(100%);
        }

        /* Floating control menu (right side) */
        #overlay-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #right-controls-hover-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 150px;
            height: 100%;
            z-index: 14;
            pointer-events: auto;
            /* CRITICAL FIX: Ensure hover zone is not draggable itself */
            -webkit-app-region: no-drag; 
        }
        #right-controls-hover-zone:hover #overlay-controls {
            opacity: 1;
            visibility: visible;
        }

        #overlay-controls button {
            padding: 0; /* Changed to 0 as buttons contain icons now */
            font-size: 1.2em; /* Base font size for icons */
            background: var(--button-toggle-bg); /* Themed */
            color: var(--text-color); /* Themed */
            border: 1px solid var(--glass-border-color); /* Themed */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            width: 40px; /* Fixed width for icon buttons */
            height: 40px; /* Fixed height for icon buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            white-space: nowrap;
            position: relative;
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        #overlay-controls button.primary {
            background: linear-gradient(135deg, var(--button-primary-start), var(--button-primary-end)); /* Themed */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        #overlay-controls button.primary:hover {
            background: linear-gradient(135deg, var(--button-primary-end), var(--button-primary-start)); /* Themed */
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        #overlay-controls button.toggle.active {
            background: linear-gradient(135deg, var(--button-toggle-active-start), var(--button-toggle-active-end));
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.4);
        }

        #overlay-controls button.toggle:not(.active):hover {
            background: var(--button-toggle-hover-bg);
        }

        /* Icons inside buttons */
        #overlay-controls button svg,
        #overlay-controls button .mark-icon { /* Apply to both SVG and Unicode icons */
            fill: currentColor;
            width: 28px; /* Consistent size for icons */
            height: 28px;
            display: block; /* Ensure correct rendering for unicode chars */
            line-height: 1; /* For vertical centering of unicode chars */
        }


        /* Image bottom navigation controls */
        #image-navigation-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            display: flex;
            gap: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #bottom-controls-hover-zone {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px; /* Increased height for easier hover activation */
            z-index: 14;
            pointer-events: auto;
            /* CRITICAL FIX: Ensure hover zone is not draggable itself */
            -webkit-app-region: no-drag;
        }
        /* When hovering over the bottom zone, show navigation controls */
        #bottom-controls-hover-zone:hover #image-navigation-controls {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s; /* No delay when showing */
        }

        #image-navigation-controls button {
            background: var(--button-nav-bg); /* Themed */
            border-radius: 50%;
            width: 65px;
            height: 65px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            color: var(--button-nav-color); /* Themed */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
            font-weight: bold;
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        #image-navigation-controls button:hover {
            background: var(--button-nav-hover-bg); /* Themed */
            transform: translateY(-4px) scale(1.1);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        }

        #image-navigation-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0) scale(1);
            box-shadow: none;
        }
        body.light-theme #image-navigation-controls button:disabled {
            background: rgba(0, 0, 0, 0.1);
            color: rgba(0, 0, 0, 0.25);
        }


        /* Top-right menu buttons */
        #top-right-menu-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        /* Styling for settings, random playback, filter marked buttons (circular icons) */
        #settings-button,
        #random-playback-toggle,
        #filter-marked-toggle {
            background: var(--button-toggle-bg); /* Themed */
            border-radius: 50%;
            width: 36px; /* Optimized fixed size */
            height: 36px; /* Optimized fixed size */
            font-size: 1.5em; /* Base font size for icons - for any unicode fallback */
            color: var(--text-color); /* Themed */
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease;
            /* Ensure centering of contents */
            display: flex; 
            justify-content: center; 
            align-items: center; 
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        #settings-button:hover,
        #random-playback-toggle:hover,
        #filter-marked-toggle:hover {
            background: var(--button-toggle-hover-bg); /* Themed */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #settings-button:hover {
            transform: rotate(15deg); 
        }

        /* NEW: Explicit active states for specific top-right circular buttons (higher specificity) */
        #random-playback-toggle.active,
        #filter-marked-toggle.active,
        #settings-button.active { 
            background: linear-gradient(135deg, var(--button-toggle-active-start), var(--button-toggle-active-end));
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.4);
        }


        /* Settings modal overlay */
        #settings-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;

            /* overlay 设为可拖动 */
            -webkit-app-region: drag;
        }

        #settings-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        #settings-modal-content {
            width: 680px; /* Further increased width to accommodate inline elements more comfortably */
            max-width: 95%; /* Adjusted max-width for very small screens */
            padding: 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;

            /* 模态框内容本身不可拖动，以便内部元素可拖动 */
            -webkit-app-region: no-drag;
        }

        #settings-modal-content h2 {
            text-align: center;
            margin-bottom: 5px; /* Reduced margin */
            color: var(--text-color); /* Themed */
            font-size: 1.8em;
        }

        /* Settings modal close button position (top-left) */
        #settings-modal-content .close-button {
            position: absolute;
            top: 10px; /* Slightly closer to edge */
            left: 10px; /* Slightly closer to edge */
            background-color: #dc3545; /* Red background for the button */
            border: none;
            font-size: 1.2em; /* Smaller font size for X */
            color: #ffffff; /* White X by default */
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, opacity 0.3s ease; /* Add opacity to transition */
            padding: 0; /* Remove padding to make it truly circular/small */
            width: 20px; /* Smaller width */
            height: 20px; /* Smaller height */
            border-radius: 50%; /* Make it circular */
            display: flex; /* Use flex to center the X inside */
            justify-content: center;
            align-items: center;
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* Make it non-interactive when hidden */
            z-index: 1; /* Ensure it's above other elements if needed */
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        #settings-modal-content:hover .close-button {
            opacity: 1; /* Show on parent hover */
            pointer-events: auto; /* Make interactive on parent hover */
        }
        #settings-modal-content .close-button:hover {
            color: #000000; /* Black color on button hover */
            background-color: rgba(255, 255, 255, 0.8); /* Light background on hover for contrast */
        }
        body.light-theme #settings-modal-content .close-button:hover {
            background-color: rgba(0, 0, 0, 0.3); /* Darker background on hover for light theme */
        }


        /* New: Theme toggle button inside settings modal (top-right) */
        #settings-modal-theme-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--button-toggle-bg); /* Themed */
            border-radius: 50%;
            width: 35px; /* Slightly smaller for settings modal */
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            color: var(--text-color); /* Themed */
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease;
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        #settings-modal-theme-toggle:hover {
            background: var(--button-toggle-hover-bg); /* Themed */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #settings-modal-theme-toggle svg {
            fill: currentColor;
            width: 24px; /* Slightly smaller icon for settings modal */
            height: 24px;
        }
        /* Updated: Light theme active color to light blue */
        #settings-modal-theme-toggle.active { /* For light theme active */
            background: linear-gradient(135deg, #87CEEB, #ADD8E6); /* Sky Blue to Light Blue */
            box-shadow: 0 2px 8px rgba(135, 206, 235, 0.4);
        }

        /* Settings section title - removed as per request for 5 lines of settings */
        /*
        .settings-section-title {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--glass-border-color);
            text-align: center;
            margin-top: 15px;
        }
        */

        /* New: Compact settings row for 5-line structure */
        .settings-row-compact {
            display: flex;
            align-items: center;
            gap: 8px; /* Slightly reduced gap */
            width: 100%;
            flex-wrap: nowrap !important; /* CRITICAL: Force items into a single line, override media queries */
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05); /* Subtle separator */
        }
        .settings-row-compact:last-of-type {
            border-bottom: none; /* No border for the last row */
        }
        .settings-row-compact label {
            flex-shrink: 0; /* Prevent label from shrinking */
            font-size: 0.9em;
            color: var(--info-text-color);
            min-width: 80px; /* Increased min-width for labels to accommodate "默认路径" etc. */
            text-align: right; /* Align labels right for better alignment with controls */
            white-space: nowrap; /* Prevent label text from wrapping */
        }

        /* Groups of controls within a row (e.g., for background settings) */
        .settings-row-compact .control-group {
            display: flex;
            align-items: center;
            gap: 5px; /* Very small gap within control groups */
            flex-shrink: 0; /* Prevent individual control groups from shrinking too much */
        }
        .settings-row-compact .control-group.background-controls {
            flex-grow: 1; /* Allow background control groups to grow */
            min-width: 220px; /* Ensure enough space for buttons */
        }
        .settings-row-compact .control-group .sub-label {
            font-size: 0.85em;
            color: var(--info-text-color);
            flex-shrink: 0;
            white-space: nowrap; /* Prevent sub-label text from wrapping */
        }

        /* Compact buttons for settings modal */
        .settings-row-compact .compact-btn {
            padding: 5px 9px; /* Even smaller padding for very tight fit */
            font-size: 0.75em; /* Even smaller font size */
            box-shadow: none;
            flex-shrink: 0; /* Important: prevent buttons from shrinking */
            /* 防止按钮成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        /* For the default path input, allow it to grow */
        .settings-row-compact .flex-grow-input-display {
            flex-grow: 1; /* Allow it to take up remaining space */
            min-width: 100px; /* A bit more minimum width */
            padding: 6px 10px;
            font-size: 0.85em;
            white-space: nowrap; /* Keep content on one line */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Show ellipsis for overflow */
            /* 防止输入框成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        
        /* Compact color picker and number input */
        .settings-row-compact .color-picker-compact {
            width: 35px; /* Slightly smaller fixed width */
            height: 28px; /* Slightly smaller height */
            padding: 2px;
            flex-shrink: 0;
            cursor: pointer;
            /* 防止颜色选择器成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        .settings-row-compact .number-input-compact {
            width: 60px; /* Fixed width for number input */
            padding: 5px 6px; /* Smaller padding */
            font-size: 0.85em;
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking */
            /* 防止输入框成为拖动区域 */
            -webkit-app-region: no-drag;
        }


        /* Radio button group for time format or preview background choice */
        .radio-group-inline {
            display: flex;
            gap: 10px; /* Reduced gap between radio options */
            flex-grow: 1; /* Allows it to take up remaining space */
            justify-content: flex-end; /* Align radios to the right, opposite of label */
            flex-wrap: nowrap !important; /* CRITICAL: Force radios into a single line, override media queries */
            min-width: 150px; /* Ensure enough space for two radios + labels */
        }
        .radio-group-inline label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
            color: var(--text-color);
            margin: 0;
            min-width: unset;
            text-align: left;
            white-space: nowrap; /* Prevent radio label text from wrapping */
            flex-shrink: 0; /* Prevent labels from shrinking */
            /* 防止标签成为拖动区域 */
            -webkit-app-region: no-drag;
        }
        /* Radio button custom styling */
        .radio-group-inline input[type="radio"] {
            -webkit-appearance: none;
            appearance: none;
            background-color: var(--input-bg);
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.15em;
            height: 1.15em;
            border: 0.15em solid var(--info-text-color);
            border-radius: 50%;
            transform: translateY(-0.075em);
            display: grid;
            place-content: center;
            transition: background-color 0.2s, border-color 0.2s;
            /* 防止单选框成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        .radio-group-inline input[type="radio"]::before {
            content: "";
            width: 0.65em;
            height: 0.65em;
            border-radius: 50%;
            transform: scale(0);
            transition: transform 0.2s ease-in-out;
            box-shadow: inset 1em 1em var(--button-toggle-active-start);
            background-color: CanvasText;
        }

        .radio-group-inline input[type="radio"]:checked::before {
            transform: scale(1);
        }
        .radio-group-inline input[type="radio"]:focus {
            outline: max(2px, 0.15em) solid currentColor;
            outline-offset: max(2px, 0.15em);
        }

        /* Single button row centering */
        .settings-row-compact.single-button-center {
            justify-content: center;
            border-bottom: none; /* Ensure no bottom border for the very last row */
        }

        /* Custom Alert Box */
        #custom-alert-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--alert-bg); /* Themed */
            backdrop-filter: blur(5px);
            border: var(--alert-border); /* Themed */
            border-radius: 12px;
            box-shadow: var(--alert-shadow); /* Themed */
            padding: 25px;
            z-index: 1000;
            color: var(--text-color); /* Themed */
            text-align: center;
            max-width: 400px; 
            width: 90%;
            /* 防止警告框成为拖动区域，因为它的子元素有按钮 */
            -webkit-app-region: no-drag;
        }
        #custom-alert-box button {
            background: linear-gradient(135deg, var(--button-primary-start), var(--button-primary-end)); /* Themed */
            color: var(--text-color); /* Themed */
        }

        /* Mark Button (now inside overlay-controls, inheriting its base styles) */
        #overlay-controls #markStarButton {
            /* Inherits width, height, background, border-radius, etc. from general #overlay-controls button */
            /* Override font-size for unicode character */
            font-size: 1.8em; /* Adjust to make the Unicode character larger, fits 40px button better */
            /* No explicit opacity/visibility here, inherited from parent #overlay-controls */
        }

        /* Style for the Unicode icon within the mark button */
        #overlay-controls #markStarButton .mark-icon {
            font-size: inherit; /* Inherits from parent button */
            line-height: 1; /* For vertical centering */
            display: block;
            /* 防止图标成为拖动区域 */
            -webkit-app-region: no-drag;
        }

        /* Marked state color for the button (background and text color handled by .active class) */
        /* No specific .marked .mark-icon color override needed if button's text color changes */


        /* Responsive adjustments - Keep these for other UI elements, but override for settings rows */
        @media (max-width: 768px) {
            #controls-menu {
                width: 95%;
                padding: 15px;
            }

            #folder-browser-view {
                width: 95%;
                height: 90vh;
                padding: 15px;
            }

            .folder-browser-header {
                flex-wrap: wrap; /* Re-enable wrapping for small screens if content exceeds width */
                justify-content: space-between; /* Keep space-between for alignment */
                gap: 5px; /* Smaller gap when stacked or tightly packed */
            }

            .folder-browser-header h1 {
                font-size: 1.5em;
            }

            .folder-browser-header #current-library-path {
                margin: 0; /* Remove horizontal margin */
                font-size: 0.8em;
                text-align: left;
                width: auto; /* Allow content-based width, flex-grow will distribute */
                flex-basis: 100%; /* Take full width on a new line if it wraps */
                order: 3; /* Push to the last line if wraps */
                white-space: normal; /* Allow wrap for long paths on small screens when on new line */
                overflow: hidden; /* Ensure overflow handling */
                text-overflow: ellipsis; /* Ensure ellipsis */
            }
            .folder-browser-header-buttons {
                flex-wrap: wrap; /* Allow buttons to wrap */
                justify-content: flex-end; /* Align right if they wrap */
                gap: 5px; /* Smaller gap */
            }
            .folder-browser-header #goUpFolderButton,
            .folder-browser-header #libraryFilterMarkedToggle {
                font-size: 0.8em;
                padding: 6px 10px;
                width: auto; /* Auto width */
            }

            #thumbnails-grid-container {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
            }

            .thumbnail-item {
                height: 140px;
            }
            .thumbnail-item img {
                max-height: 90px;
            }
            .thumbnail-item .folder-icon {
                font-size: 50px;
            }

            button {
                padding: 10px 20px;
                font-size: 0.9em;
            }

            input[type="number"],
            input[type="text"] {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            .custom-input-like-button {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            #countdown {
                font-size: 2em;
                top: 10px;
                left: 10px;
            }

            #overlay-controls {
                top: 10px;
                right: 10px;
                gap: 8px;
            }
            #overlay-controls button {
                width: 35px;
                height: 35px;
            }
            #overlay-controls button svg,
            #overlay-controls button .mark-icon {
                width: 24px;
                height: 24px;
            }

            #image-navigation-controls button {
                width: 50px;
                height: 50px;
                font-size: 2em;
            }

            #top-right-menu-buttons {
                top: 10px;
                right: 10px;
                gap: 8px;
            }
            /* Main menu circular icon buttons (settings, random, filter marked) - keeping fixed sizes, no more scaling */
            #settings-button,
            #random-playback-toggle,
            #filter-marked-toggle { 
                width: 36px; /* Fixed size, not scaled by media query */
                height: 36px; /* Fixed size, not scaled by media query */
                font-size: 1.5em; /* Not scaled by media query */
            }
            #settings-button svg,
            #random-playback-toggle svg,
            #filter-marked-toggle svg {
                width: 24px; /* Fixed size, not scaled by media query */
                height: 24px; /* Fixed size, not scaled by media query */
            }

            #settings-modal-content {
                width: 95%; /* Make it almost full width on small screens */
                padding: 20px;
                gap: 10px; /* Further reduce gap on small screens */
            }

            /* Settings row adjustments for mobile - will be overridden by !important now */
            .settings-row-compact {
                flex-direction: row; /* Keep as row due to nowrap */
                align-items: center;
                gap: 5px; /* Smaller gap */
                justify-content: space-between; /* Distribute items */
                white-space: nowrap; /* Ensure no wrapping */
                overflow-x: auto; /* Add horizontal scroll for settings row if needed on very small screens */
            }
            .settings-row-compact label {
                width: auto; /* Reset width */
                text-align: right;
                min-width: unset; /* Reset min-width */
            }
            .settings-row-compact .control-group {
                width: auto; /* Reset width */
                flex-grow: 0;
            }
            .settings-row-compact .compact-btn {
                flex-grow: 0; /* Reset flex-grow */
            }
            .settings-row-compact .flex-grow-input-display {
                width: auto; /* Reset width */
                min-width: 50px; /* Smallest possible input on mobile */
            }

            .radio-group-inline {
                flex-direction: row; /* Keep as row due to nowrap */
                justify-content: flex-end;
                gap: 5px; /* Smaller gap */
            }
            .radio-group-inline label {
                width: auto; /* Reset width */
            }

            #settings-modal-theme-toggle {
                width: 30px; /* Even smaller for settings modal on small screen */
                height: 30px;
            }
            #settings-modal-theme-toggle svg {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- New: Dedicated layer for dynamic preview backgrounds -->
    <div id="dynamic-background-layer"></div>

    <div id="app-container">
        <!-- 控制菜单 -->
        <div id="controls-menu" class="glassmorphism">
            <h1>限时速写工具</h1>
            <!-- 整合后的文件夹选择和路径显示区域 -->
            <div class="input-group">
                <label>速写文件夹:</label>
                <div id="sketchFolderInputDisplay" class="custom-input-like-button">
                    点击选择速写文件夹...
                </div>
            </div>

            <div class="input-group">
                <label for="displayTime">每张图片显示时间 (秒):</label>
                <input type="number" id="displayTime" value="60" min="1">
            </div>
            <!-- 常用时间选项 - 放在同一行 -->
            <div class="buttons-group" id="preset-time-buttons" style="flex-wrap: nowrap; overflow-x: auto;">
                <button id="preset30s" class="toggle">30秒</button>
                <button id="preset60s" class="toggle active">60秒</button> <!-- 默认激活 -->
                <button id="preset120s" class="toggle">120秒</button>
                <button id="preset300s" class="toggle">300秒</button>
                <button id="preset600s" class="toggle">600秒</button>
                <button id="presetInfiniteTime" class="toggle">♾️</button> <!-- NEW: Infinite time option -->
            </div>
            <div class="buttons-group">
                <button id="startButton" class="primary" data-tooltip="开始速写">开始速写</button>
            </div>
            <div class="buttons-group">
                <button id="mirrorToggle" class="toggle">镜像</button>
                <button id="grayscaleToggle" class="toggle">灰度</button>
                <button id="gridToggle" class="toggle">网格</button>
                <!-- Existing Always On Top button for main menu, re-ordered and styled -->
                <button id="mainMenuAlwaysOnTopToggle" class="toggle">
                    置顶
                </button>
            </div>
            <!-- Modified hint text element -->
            <p id="mainMenuHintText" style="font-size: 0.8em; text-align: center; color: var(--info-text-color); margin-top: 15px;">
                选择文件夹以开始速写。
            </p>

            <!-- 设置按钮和随机/顺序播放按钮 - 右上角图标 -->
            <div id="top-right-menu-buttons">
                <button id="filter-marked-toggle" class="toggle active" data-tooltip="过滤已标记">
                    <!-- Icon for filtering marked images (e.g., a filter or tag icon) -->
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/>
                    </svg>
                </button>
                <button id="random-playback-toggle" class="toggle" data-tooltip="随机">
                    <!-- Icon for random playback (shuffle) -->
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10.59 9.17L5.41 4H21V2H3v10.59l5.59-5.59 2.59 2.58zM14.59 14.83L19.59 19H3v2h18v-9.59L14.59 14.83z"/>
                    </svg>
                </button>
                <button id="settings-button" class="toggle" data-tooltip="设置">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 2a8 8 0 100 16 8 8 0 000-16zM12 6a6 6 0 110 12 6 6 0 010-12z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- 图片显示区域 -->
        <div id="image-display-area" class="hidden">
            <img id="current-image" src="" alt="当前速写图片">
            <canvas id="grid-canvas"></canvas>
            <div id="countdown"></div>

            
            <!-- 鼠标悬停区域 - 右侧 -->
            <div id="right-controls-hover-zone">
                <!-- 浮动控制菜单 (播放时鼠标悬停显示) -->
                <div id="overlay-controls" class="glassmorphism">
                    <button id="openInFinderButton" class="toggle" data-tooltip="在文件夹中打开">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/>
                        </svg>
                    </button>
                    <!-- New: Mark Button - moved here -->
                    <button id="markStarButton" class="toggle" data-tooltip="未标记">
                        <span class="mark-icon">&#x2022;</span> <!-- Simple Dot -->
                    </button>
                    <button id="overlayMirrorToggle" class="toggle" data-tooltip="镜像">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M11 5H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h5v2h2V3h-2v2zm7 0h-5v2h5c1.1 0 2 .9 2 2v6c0 1.1-.9 2-2 2h-5v2h5c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2z"/>
                        </svg>
                    </button>
                    <button id="overlayGrayscaleToggle" class="toggle" data-tooltip="灰度">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20 4h-4L12 12 8 4H4v16h4v-8l4 8 4-8v8h4V4zm-8 4l-4 8H8l4-8 4 8h-4V4z"/>
                        </svg>
                    </button>
                    <button id="overlayGridToggle" class="toggle" data-tooltip="网格">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"/>
                        </svg>
                    </button>
                    <button id="toggleAlwaysOnTopButton" class="toggle" data-tooltip="置顶">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 17h10V7H7v10zm2-8h6v6H9V9zm-5 4V9c0-1.1.9-2 2-2h4V5H6c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h4v-2H6v2c-1.1 0-2-.9-2-2zm14 0c0 1.1-.9 2-2 2h-4v2h4c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-4v2h4v2c1.1 0 2 .9 2 2v4z"/>
                        </svg>
                    </button>
                    <button id="backToMenuButton" class="primary" data-tooltip="返回菜单">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 鼠标悬停区域 - 底部 -->
            <div id="bottom-controls-hover-zone">
                <!-- 图片底部导航按钮 -->
                <div id="image-navigation-controls">
                    <button id="prevImageButton" class="toggle">
                        ‹
                    </button>
                    <button id="pausePlayButton" class="toggle">
                        <!-- 初始为暂停图标 -->
                        ⏸
                    </button>
                    <button id="nextImageButton" class="toggle">
                        ›
                    </button>
                </div>
            </div>
        </div>

        <!-- 文件夹浏览器视图 -->
        <div id="folder-browser-view" class="glassmorphism">
            <!-- New: Folder browser header -->
            <div class="folder-browser-header">
                <h1>图片库</h1>
                <div id="current-library-path"></div>
                <div class="folder-browser-header-buttons">
                    <button id="libraryFilterMarkedToggle" class="toggle" data-tooltip="过滤已标记">
                        <span class="mark-icon">&#x2022;</span> <!-- Solid circle icon for consistency -->
                    </button>
                    <button id="goUpFolderButton" class="toggle">
                        <span style="font-size: 1.2em; margin-right: 5px;">⬆</span>返回上级
                    </button>
                </div>
            </div>
            
            <div id="thumbnails-grid-container">
                <!-- 图片缩略图将在此处动态加载 -->
                <p class="info-message" id="folderBrowserInfoMessage">加载中...</p>
            </div>
            <!-- 分页控件 -->
            <div class="buttons-group" style="width: 100%; justify-content: space-between; margin-top: 10px;">
                <button id="prevPageButton" class="toggle">上一页</button>
                <span id="pageInfoDisplay" style="color: var(--info-text-color); font-size: 0.9em;"></span>
                <button id="nextPageButton" class="toggle">下一页</button>
            </div>
            <div class="buttons-group">
                <button id="selectFolderForSketchAndReturnToMenuButton" class="primary">选择此文件夹</button>
                <button id="selectNewFolderFromBrowserButton" class="primary">选择其他文件夹</button>
                <button id="backFromBrowserToMenuButton" class="primary">返回主菜单</button>
            </div>
        </div>
    </div>

    <!-- 设置模态框 -->
    <div id="settings-modal-overlay">
        <div id="settings-modal-content" class="glassmorphism">
            <button class="close-button" id="closeSettingsModal">&times;</button>
            <!-- New: Theme toggle button inside settings modal -->
            <button id="settings-modal-theme-toggle" class="toggle" data-tooltip="切换主题">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <!-- Standard Sun icon path (corrected) -->
                    <path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 2a8 8 0 100 16 8 8 0 000-16zM12 6a6 6 0 110 12 6 6 0 010-12z"/>
                </svg>
            </button>

            <h2>设置</h2>

            <!-- Row 1: 菜单背景设置 -->
            <div class="settings-row-compact">
                <label>菜单背景:</label>
                <div class="radio-group-inline" id="mainMenuBackgroundChoiceRadiosGroup">
                    <label><input type="radio" name="mainMenuBackgroundChoice" value="solidColor" checked> 纯色</label>
                    <label><input type="radio" name="mainMenuBackgroundChoice" value="staticImage"> 图片</label>
                </div>
            </div>

            <!-- Conditionally visible row for Main Menu Static Image Path Selection -->
            <div class="settings-row-compact" id="mainMenuStaticImagePathRow" style="display: none;">
                <label></label> <!-- Empty label to maintain alignment -->
                <input type="text" id="mainMenuBackgroundPathDisplay" readonly placeholder="未选择静态图片" class="flex-grow-input-display">
                <button id="selectMainMenuImageButton" class="primary compact-btn">选择</button>
                <button id="clearMainMenuImageButton" class="primary compact-btn">清除</button>
            </div>
            
            <!-- Row (Modified): 预览背景模式 -->
            <div class="settings-row-compact">
                <label>预览背景:</label>
                <div class="radio-group-inline" id="previewBackgroundChoiceRadiosGroup">
                    <label><input type="radio" name="previewBackgroundChoice" value="solidColor"> 纯色</label>
                    <label><input type="radio" name="previewBackgroundChoice" value="averageColor"> 平均色</label>
                    <label><input type="radio" name="previewBackgroundChoice" value="staticImage"> 静态图片</label>
                </div>
            </div>

            <!-- Conditionally visible row for Preview Static Image Path Selection -->
            <div class="settings-row-compact" id="staticImagePathRow" style="display: none;">
                <label></label> <!-- Empty label to maintain alignment -->
                <input type="text" id="previewBackgroundPathDisplay" readonly placeholder="未选择静态图片" class="flex-grow-input-display">
                <button id="selectStaticImageButton" class="primary compact-btn">选择</button>
                <button id="clearStaticImageButton" class="primary compact-btn">清除</button>
            </div>

            <!-- Row 2: 默认路径 -->
            <div class="settings-row-compact">
                <label>默认路径:</label>
                <input type="text" id="defaultImageFolderPathDisplay" readonly placeholder="未设置默认路径" class="flex-grow-input-display">
                <button id="setDefaultImageFolderButton" class="primary compact-btn">设置</button>
                <button id="clearDefaultImageFolderButton" class="primary compact-btn">清除</button>
            </div>

            <!-- Row 3: 网格设置 -->
            <div class="settings-row-compact">
                <label>网格:</label>
                <span class="sub-label">颜色:</span>
                <input type="color" id="gridColorPicker" value="#FFFFFF" class="color-picker-compact">
                <span class="sub-label">大小 (px):</span>
                <input type="number" id="gridSizeInput" value="50" min="10" max="200" step="10" class="number-input-compact">
                <button id="resetGridSettingsButton" class="primary compact-btn">重置</button> <!-- Combined reset for grid -->
            </div>

            <!-- Row 4: 时间格式 -->
            <div class="settings-row-compact">
                <label>时间格式:</label>
                <div class="radio-group-inline">
                    <label><input type="radio" name="timeFormat" value="hours:minutes:seconds" checked> 时:分:秒</label>
                    <label><input type="radio" name="timeFormat" value="seconds"> 只秒</label>
                </div>
            </div>

            <!-- Row 5: 工具 -->
            <div class="settings-row-compact single-button-center">
                <button id="openSketchLogButton" class="primary">打开速写日志</button>
            </div>
        </div>
    </div>
    
    <!-- 隐藏的 Canvas，用于计算平均颜色 -->
    <canvas id="hidden-image-canvas" style="display: none;"></canvas>

    <script>
        // Get DOM elements
        const appContainer = document.getElementById('app-container');
        // New: Dedicated background layer element
        const dynamicBackgroundLayer = document.getElementById('dynamic-background-layer');

        const controlsMenu = document.getElementById('controls-menu');
        const sketchFolderInputDisplay = document.getElementById('sketchFolderInputDisplay'); // Main menu sketch folder display/selection area
        const displayTimeInput = document.getElementById('displayTime');
        const startButton = document.getElementById('startButton');
        const mirrorToggle = document.getElementById('mirrorToggle');
        const grayscaleToggle = document.getElementById('grayscaleToggle');
        const gridToggle = document.getElementById('gridToggle');
        const mainMenuHintText = document.getElementById('mainMenuHintText'); // New: Main menu hint text element

        // Preset time buttons and their container
        const presetTimeButtonsContainer = document.getElementById('preset-time-buttons');
        const preset30sButton = document.getElementById('preset30s');
        const preset60sButton = document.getElementById('preset60s'); 
        const preset120sButton = document.getElementById('preset120s');
        const preset300sButton = document.getElementById('preset300s'); 
        const preset600sButton = document.getElementById('preset600s'); 
        const presetInfiniteTime = document.getElementById('presetInfiniteTime'); // NEW: Infinite time option
        const presetTimes = [30, 60, 120, 300, 600, Infinity]; // Array of preset times, including Infinity

        const imageDisplayArea = document.getElementById('image-display-area');
        const currentImage = document.getElementById('current-image');
        const countdownElement = document.getElementById('countdown');
        const gridCanvas = document.getElementById('grid-canvas');
        const ctx = gridCanvas.getContext('2d'); 

        // Right floating control menu and hover area
        const rightControlsHoverZone = document.getElementById('right-controls-hover-zone');
        const overlayControls = document.getElementById('overlay-controls');
        const openInFinderButton = document.getElementById('openInFinderButton'); 
        
        // New: Mark Star Button
        const markStarButton = document.getElementById('markStarButton'); 

        const overlayMirrorToggle = document.getElementById('overlayMirrorToggle');
        const overlayGrayscaleToggle = document.getElementById('overlayGrayscaleToggle');
        const overlayGridToggle = document.getElementById('overlayGridToggle');
        const toggleAlwaysOnTopButton = document.getElementById('toggleAlwaysOnTopButton'); 
        const backToMenuButton = document.getElementById('backToMenuButton');

        // Image bottom navigation buttons and hover area
        const bottomControlsHoverZone = document.getElementById('bottom-controls-hover-zone');
        const imageNavigationControls = document.getElementById('image-navigation-controls'); 
        const prevImageButton = document.getElementById('prevImageButton'); 
        const nextImageButton = document.getElementById('nextImageButton');
        const pausePlayButton = document.getElementById('pausePlayButton'); 

        // Settings modal related elements
        const settingsButton = document.getElementById('settings-button'); 
        const randomPlaybackToggle = document.getElementById('random-playback-toggle'); // New random/sequential playback button
        // New: Filter Marked Images Toggle
        const filterMarkedToggle = document.getElementById('filter-marked-toggle');
        // Main Menu Always On Top Toggle (now consistent with Mirror/Grayscale/Grid)
        const mainMenuAlwaysOnTopToggle = document.getElementById('mainMenuAlwaysOnTopToggle');

        // New: Top-right menu buttons container
        const topRightMenuButtons = document.getElementById('top-right-menu-buttons');

        const settingsModalOverlay = document.getElementById('settings-modal-overlay');
        const closeSettingsModalButton = document.getElementById('closeSettingsModal');
        // Main Menu Background New Elements
        const mainMenuBackgroundChoiceRadios = document.querySelectorAll('input[name="mainMenuBackgroundChoice"]');
        const mainMenuStaticImagePathRow = document.getElementById('mainMenuStaticImagePathRow');
        const mainMenuBackgroundPathDisplay = document.getElementById('mainMenuBackgroundPathDisplay');
        const selectMainMenuImageButton = document.getElementById('selectMainMenuImageButton');
        const clearMainMenuImageButton = document.getElementById('clearMainMenuImageButton');

        // Renamed/Refactored Preview Background Buttons
        const previewBackgroundChoiceRadios = document.querySelectorAll('input[name="previewBackgroundChoice"]');
        const staticImagePathRow = document.getElementById('staticImagePathRow');
        const previewBackgroundPathDisplay = document.getElementById('previewBackgroundPathDisplay');
        const selectStaticImageButton = document.getElementById('selectStaticImageButton');
        const clearStaticImageButton = document.getElementById('clearStaticImageButton');

        const gridColorPicker = document.getElementById('gridColorPicker'); 
        const resetGridSettingsButton = document.getElementById('resetGridSettingsButton'); // Combined reset button
        const gridSizeInput = document.getElementById('gridSizeInput'); 
        const timeFormatRadios = document.querySelectorAll('input[name="timeFormat"]'); 
        const settingsModalThemeToggle = document.getElementById('settings-modal-theme-toggle'); // New theme toggle button inside settings modal
        const openSketchLogButton = document.getElementById('openSketchLogButton'); // New: Open Sketch Log Button

        // Default image folder settings related DOM elements
        const defaultImageFolderPathDisplay = document.getElementById('defaultImageFolderPathDisplay');
        const setDefaultImageFolderButton = document.getElementById('setDefaultImageFolderButton');
        const clearDefaultImageFolderButton = document.getElementById('clearDefaultImageFolderButton');

        // Folder browser view DOM elements
        const folderBrowserView = document.getElementById('folder-browser-view');
        const currentLibraryPathDisplay = document.getElementById('current-library-path');
        const thumbnailsGridContainer = document.getElementById('thumbnails-grid-container');
        const selectFolderForSketchAndReturnToMenuButton = document.getElementById('selectFolderForSketchAndReturnToMenuButton'); 
        const selectNewFolderFromBrowserButton = document.getElementById('selectNewFolderFromBrowserButton');
        const backFromBrowserToMenuButton = document.getElementById('backFromBrowserToMenuButton');
        const folderBrowserInfoMessage = document.getElementById('folderBrowserInfoMessage'); 
        const goUpFolderButton = document.getElementById('goUpFolderButton'); 
        // New: Library Filter Marked Toggle
        const libraryFilterMarkedToggle = document.getElementById('libraryFilterMarkedToggle');


        // Pagination elements
        const prevPageButton = document.getElementById('prevPageButton');
        const nextPageButton = document.getElementById('nextPageButton');
        const pageInfoDisplay = document.getElementById('pageInfoDisplay');

        // New: Hidden Canvas for Average Color Calculation
        const hiddenImageCanvas = document.getElementById('hidden-image-canvas');
        const hiddenImageCtx = hiddenImageCanvas.getContext('2d', { willReadFrequently: true }); // Optimized for frequent reads


        // State variables
        let imageFiles = []; // Stores image file objects (including original path etc.) for sketching
        let imageUrls = []; // Stores file:// URLs for displaying images for sketching
        let currentPlaybackImageIndexes = []; // Stores raw indices of images currently eligible for playback
        let currentImageIndex = -1; 
        let displayTime = 60; 
        let countdownTimer; 
        let remainingTime; 
        let isPlaying = false; 
        let isPaused = false; 
        let currentDefaultImageFolderPath = ''; // Saves current default image folder path
        let currentLoadedFolderPath = ''; // Saves current folder path loaded in image library view

        // Effect states
        let isMirrorEnabled = false;
        let isGrayscaleEnabled = false;
        let isGridEnabled = false;
        let isAlwaysOnTop = false; 
        let isRandomPlayback = true; // New: default to random playback
        let isFilterMarkedEnabled = true; // New: default to true (filter marked images) - for playback
        let isLibraryFilterMarkedEnabled = false; // New: default to false (show all images) - for library view
        let isLightThemeEnabled = false; // New: default to dark theme
        // Updated: Preview background choice can be 'solidColor', 'averageColor', 'staticImage'
        let previewBackgroundChoice = 'solidColor'; // New: default preview background mode
        let mainMenuBackgroundChoice = 'solidColor'; // New: default main menu background mode


        // Image playback history
        let displayedImageHistory = [];
        let historyPointer = -1; 

        // New: Global image marks object. Keys are original file paths, values are arrays of { duration, timestamp }
        let imageMarks = {}; 

        // Default settings values
        const defaultGridColorHex = '#FFFFFF'; 
        const defaultGridSize = 50; 
        const defaultTimeFormat = 'hours:minutes:seconds'; // Changed default to "时:分:秒"
        const gridAlpha = 0.3; 

        // Current setting values (will be loaded from storage)
        let currentMainMenuBackgroundPath = ''; // This will store the path for 'staticImage' mode for main menu
        let currentPreviewBackgroundPath = ''; // This will store the path for 'staticImage' mode for preview
        let currentGridColorHex = defaultGridColorHex;
        let currentGridSize = defaultGridSize;
        let currentTimeFormat = defaultTimeFormat;

        // Pagination state
        const itemsPerPage = 30; // Number of items (folders + images) to display per page
        let currentFolderItems = []; // Stores ALL sorted items (directories + files) for the current folder view
        let currentPage = 0; // 0-indexed page number


        /**
         * Natural sort comparator function for strings, handling numbers correctly.
         * From: https://stackoverflow.com/questions/38640203/javascript-sort-array-of-objects-by-property-containing-numbers-and-letters
         * @param {object} a - First object with a 'name' property to compare.
         * @param {object} b - Second object with a 'name' property to compare.
         * @returns {number} - Comparison result.
         */
        function naturalSort(a, b) {
            // Ensure 'name' properties exist before calling localeCompare
            const nameA = a.name || '';
            const nameB = b.name || '';
            return nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
        }


        /**
         * Displays a custom alert box, replacing the native alert.
         * @param {string} message - Message to display.
         * @param {string} [title="Tip"] - Title of the alert box.
         */
        function showCustomAlert(message, title = "Tip") {
            // Remove existing alert box if any
            const existingAlert = document.getElementById('custom-alert-box');
            if (existingAlert) {
                existingAlert.remove();
            }

            const alertBox = document.createElement('div');
            alertBox.id = 'custom-alert-box'; // Assign ID for easy removal
            alertBox.innerHTML = `
                <h3 style="margin-bottom: 15px; font-size: 1.3em;">${title}</h3>
                <p style="margin-bottom: 20px; font-size: 1em; line-height: 1.5;">${message}</p>
                <button id="alertCloseButton" style="
                    padding: 10px 20px;
                    border: none;
                    border-radius: 8px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: background 0.3s ease, color 0.3s ease;
                ">确定</button>
            `;
            document.body.appendChild(alertBox);

            document.getElementById('alertCloseButton').addEventListener('click', () => {
                document.body.removeChild(alertBox);
            });
        }

        /**
         * Applies the selected theme to the body element.
         * @param {boolean} isLight - True for light theme, false for dark theme.
         */
        function applyTheme(isLight) {
            isLightThemeEnabled = isLight;
            document.body.classList.toggle('light-theme', isLight);
            // Update settings modal theme toggle button state
            settingsModalThemeToggle.classList.toggle('active', isLight);
            if (window.electronAPI) {
                window.electronAPI.saveSetting('isLightThemeEnabled', isLight);
            }
            // Reapply current background to ensure theme changes reflect
            if (!imageDisplayArea.classList.contains('hidden')) {
                // If in preview mode, reapply preview background based on choice
                updatePreviewBackground(); // Use unified function
            } else {
                // If in menu/browser mode, reapply main menu background
                updateMainMenuBackground(); // Use unified function
            }
            // Redraw grid if enabled to update its color based on theme
            if (isGridEnabled && !imageDisplayArea.classList.contains('hidden')) {
                setGridColor(currentGridColorHex); // This will trigger drawGrid
            }
        }

        /**
         * Calculates the average RGB color of an image loaded onto a canvas.
         * @param {HTMLImageElement} imgElement - The image element to analyze.
         * @returns {string} - The average color in 'rgb(R,G,B)' format.
         */
        function getAverageColor(imgElement) {
            if (!imgElement.complete) {
                console.warn('Image not fully loaded for average color calculation.');
                return 'rgb(0,0,0)'; // Return black or transparent if not loaded
            }

            // Set canvas dimensions to image natural dimensions for full resolution sampling
            // Use Math.max to prevent zero dimensions if image is not yet fully rendered
            hiddenImageCanvas.width = Math.max(1, imgElement.naturalWidth || imgElement.offsetWidth);
            hiddenImageCanvas.height = Math.max(1, imgElement.naturalHeight || imgElement.offsetHeight);

            if (hiddenImageCanvas.width === 0 || hiddenImageCanvas.height === 0) {
                console.warn('Cannot get average color for an image with zero dimensions after setting canvas.');
                return 'rgb(0,0,0)';
            }

            hiddenImageCtx.clearRect(0, 0, hiddenImageCanvas.width, hiddenImageCanvas.height);
            hiddenImageCtx.drawImage(imgElement, 0, 0, hiddenImageCanvas.width, hiddenImageCanvas.height);

            const imageData = hiddenImageCtx.getImageData(0, 0, hiddenImageCanvas.width, hiddenImageCanvas.height).data;
            let r = 0, g = 0, b = 0;
            let count = 0;
            const pixelCount = hiddenImageCanvas.width * hiddenImageCanvas.height;
            // Sample up to 10,000 pixels for performance, or every pixel if image is small
            const step = Math.max(1, Math.floor(pixelCount / 10000)); 

            for (let i = 0; i < imageData.length; i += 4 * step) { // Increment by 4 (RGBA) * step
                // const alpha = imageData[i + 3]; // Alpha component (not used for average color)
                r += imageData[i];
                g += imageData[i + 1];
                b += imageData[i + 2];
                count++;
            }

            if (count === 0) return 'rgb(0,0,0)'; // Avoid division by zero if all pixels are transparent or image is too small

            const avgR = Math.floor(r / count);
            const avgG = Math.floor(g / count);
            const avgB = Math.floor(b / count);

            return `rgb(${avgR},${avgG},${avgB})`;
        }


        /**
         * Applies background to a specified element based on type and source.
         * @param {HTMLElement} targetElement - The element to apply the background to (e.g., document.body or dynamicBackgroundLayer).
         * @param {'menuGradient'|'previewSolid'|'staticImage'|'averageColor'} backgroundType - The type of background to apply.
         * @param {string} [sourcePath=''] - The file path for 'staticImage' type, or a dynamic color for 'averageColor'.
         */
        function applyBackground(targetElement, backgroundType, sourcePath = '') {
            // Clear previous styles from the target element first
            targetElement.style.backgroundImage = '';
            targetElement.style.backgroundColor = '';
            targetElement.style.backgroundSize = '';
            targetElement.style.backgroundPosition = '';
            targetElement.style.backgroundRepeat = '';
            targetElement.style.backgroundAttachment = '';

            if (backgroundType === 'menuGradient') {
                targetElement.style.backgroundImage = `linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end))`;
            } else if (backgroundType === 'previewSolid') {
                targetElement.style.backgroundColor = getComputedStyle(document.body).getPropertyValue('--default-preview-bg');
            } else if (backgroundType === 'staticImage' && sourcePath) {
                targetElement.style.backgroundImage = `url('file://${sourcePath}')`;
                targetElement.style.backgroundSize = 'cover';
                targetElement.style.backgroundPosition = 'center center';
                targetElement.style.backgroundRepeat = 'no-repeat';
                targetElement.style.backgroundAttachment = 'fixed';
            } else if (backgroundType === 'averageColor' && sourcePath) {
                targetElement.style.backgroundColor = sourcePath;
            } else {
                // Fallback to default solid preview background
                targetElement.style.backgroundColor = getComputedStyle(document.body).getPropertyValue('--default-preview-bg');
                console.warn(`Invalid backgroundType or missing sourcePath for background application on ${targetElement.id}: ${backgroundType}, ${sourcePath}`);
            }
        }

        /**
         * Updates the main menu and folder browser background based on selected choice.
         */
        function updateMainMenuBackground() {
            // Ensure the dynamic layer is not showing its background
            dynamicBackgroundLayer.style.backgroundImage = 'none';
            dynamicBackgroundLayer.style.backgroundColor = 'transparent';
            dynamicBackgroundLayer.classList.remove('grayscale-active-bg'); // Ensure grayscale is off for this layer

            if (mainMenuBackgroundChoice === 'staticImage') {
                applyBackground(document.body, 'staticImage', currentMainMenuBackgroundPath);
            } else { // 'solidColor' (which maps to 'menuGradient' for main menu)
                applyBackground(document.body, 'menuGradient');
            }
        }

        /**
         * Updates the preview background based on selected choice (solid, average, static image).
         * This function now only handles setting the background image/color.
         * Grayscale effect is handled by updatePreviewBackgroundGrayscaleEffect().
         */
        function updatePreviewBackground() {
            // Ensure the body's background is transparent when preview layer is active
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = 'transparent';

            if (previewBackgroundChoice === 'averageColor') {
                if (currentImage.complete && currentImage.naturalWidth > 0) {
                    const avgColor = getAverageColor(currentImage);
                    applyBackground(dynamicBackgroundLayer, 'averageColor', avgColor);
                } else {
                    applyBackground(dynamicBackgroundLayer, 'previewSolid'); // Fallback
                }
            } else if (previewBackgroundChoice === 'staticImage') {
                applyBackground(dynamicBackgroundLayer, 'staticImage', currentPreviewBackgroundPath);
            } else { // 'solidColor'
                applyBackground(dynamicBackgroundLayer, 'previewSolid');
            }
        }

        /**
         * Controls the grayscale filter on the background (dynamicBackgroundLayer).
         * Applies grayscale only if grayscale effect is enabled AND background is 'averageColor' or 'solidColor'.
         */
        function updatePreviewBackgroundGrayscaleEffect() {
            if (isGrayscaleEnabled && (previewBackgroundChoice === 'averageColor' || previewBackgroundChoice === 'solidColor')) {
                dynamicBackgroundLayer.classList.add('grayscale-active-bg');
            } else {
                dynamicBackgroundLayer.classList.remove('grayscale-active-bg');
            }
        }

        /**
         * Display the main menu interface
         * @param {string} [selectedFolderForSketch] - The folder path selected from the image library
         */
        function showMainMenu(selectedFolderForSketch = null) {
            controlsMenu.classList.remove('hidden');
            folderBrowserView.classList.add('hidden'); // Hide image library view
            imageDisplayArea.classList.add('hidden'); // Hide image display area
            topRightMenuButtons.classList.remove('hidden'); // Show top-right menu buttons

            // Clear background from dynamic layer and apply to body
            dynamicBackgroundLayer.style.backgroundImage = 'none';
            dynamicBackgroundLayer.style.backgroundColor = 'transparent';
            dynamicBackgroundLayer.classList.remove('grayscale-active-bg'); // Ensure grayscale is off for this layer
            updateMainMenuBackground(); // Apply main menu background to body

            updateNavigationButtons(); // Update button states

            // If a path is brought back from the image library, update the main menu display
            if (selectedFolderForSketch) {
                sketchFolderInputDisplay.textContent = selectedFolderForSketch;
                // At this point, imageFiles and imageUrls should have been populated by showFolderBrowserView
                // Re-calculate playback pool to ensure start button reflects filter state correctly
                updatePlaybackImagePool(); 
            } else {
                // Otherwise, reset to unselected state and disable start button
                sketchFolderInputDisplay.textContent = '点击选择速写文件夹...'; // Initial prompt text
                imageFiles = [];
                imageUrls = [];
                currentPlaybackImageIndexes = []; // Also clear playback pool
                updatePlaybackImagePool(); // Update the button state for "no folder selected"
            }
            updateMainMenuHintText(); // Update hint text when showing main menu

            // Show traffic lights when in main menu
            if (window.electronAPI) {
                window.electronAPI.setTrafficLightVisibility(true);
            }
        }

        /**
         * Checks if all images directly within a given folder are marked.
         * This function does NOT recurse into subdirectories.
         * @param {string} folderPath - The path to the folder to check.
         * @returns {Promise<boolean>} - True if all direct images are marked, false otherwise.
         */
        async function isFolderCompleted(folderPath) {
            if (!window.electronAPI) {
                console.warn('Electron API not available for folder completion check.');
                return false;
            }

            try {
                const items = await window.electronAPI.readFolderImages(folderPath);
                const directImages = items.filter(item => item.type === 'file');

                if (directImages.length === 0) {
                    return false; // A folder with no direct images cannot be "completed"
                }

                for (const imageFile of directImages) {
                    // Note: imageFile.originalPath is used here because imageMarks keys are original paths
                    if (!imageMarks[imageFile.originalPath] || imageMarks[imageFile.originalPath].length === 0) {
                        return false; // Found an unmarked image
                    }
                }
                return true; // All direct images found were marked
            } catch (error) {
                console.error(`Error checking folder completion for ${folderPath}:`, error);
                return false; // Assume not completed if an error occurs
            }
        }


        /**
         * Renders thumbnails for the current page in the folder browser.
         * This function is now async because it awaits `isFolderCompleted`.
         */
        async function renderCurrentPageThumbnails() {
            thumbnailsGridContainer.innerHTML = ''; // Clear previous thumbnails
            folderBrowserInfoMessage.classList.add('hidden'); // Hide info message by default

            const startIndex = currentPage * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, currentFolderItems.length);
            const itemsToDisplay = currentFolderItems.slice(startIndex, endIndex);

            if (itemsToDisplay.length === 0 && currentFolderItems.length === 0) {
                folderBrowserInfoMessage.textContent = '当前文件夹为空。';
                folderBrowserInfoMessage.classList.remove('hidden');
            } else if (itemsToDisplay.length === 0 && currentFolderItems.length > 0) {
                 // Should not happen if pagination logic is correct, but as a safeguard
                folderBrowserInfoMessage.textContent = '没有更多项目了。';
                folderBrowserInfoMessage.classList.remove('hidden');
            }

            for (const item of itemsToDisplay) { // Changed to for...of loop to use await
                const thumbnailItem = document.createElement('div');
                thumbnailItem.classList.add('thumbnail-item');
                
                if (item.type === 'directory') {
                    thumbnailItem.innerHTML = `
                        <span class="folder-icon">📁</span>
                        <div class="thumbnail-label">${item.name}</div>
                    `;
                    thumbnailItem.addEventListener('click', () => showFolderBrowserView(item.path)); // Click folder to enter

                    // New: Check if folder is completed and add a mark
                    const completed = await isFolderCompleted(item.path); // Await this async call
                    if (completed) {
                        const completedInfoDiv = document.createElement('div');
                        completedInfoDiv.classList.add('thumbnail-folder-completed-info');
                        completedInfoDiv.textContent = '已完成';
                        thumbnailItem.appendChild(completedInfoDiv);
                    }

                } else if (item.type === 'file') {
                    const imgElement = document.createElement('img');
                    imgElement.src = item.path; // Use file:// protocol path
                    imgElement.alt = item.name;

                    const labelElement = document.createElement('div');
                    labelElement.classList.add('thumbnail-label');
                    labelElement.textContent = item.name;

                    thumbnailItem.appendChild(imgElement);
                    thumbnailItem.appendChild(labelElement);

                    // Add mark info and delete button
                    const marks = imageMarks[item.originalPath];
                    if (marks && marks.length > 0) {
                        const latestMark = marks.sort((a, b) => b.timestamp - a.timestamp)[0];
                        const date = new Date(latestMark.timestamp);
                        const month = (date.getMonth() + 1).toString().padStart(2, '0');
                        const day = date.getDate().toString().padStart(2, '0');
                        const formattedDateShort = `${month}/${day}`;

                        const markInfoDiv = document.createElement('div');
                        markInfoDiv.classList.add('thumbnail-mark-info');
                        markInfoDiv.innerHTML = `
                            ${formattedDateShort} (${latestMark.duration === 0 ? '∞' : latestMark.duration + 's'})
                            <span class="delete-mark-button" data-path="${item.originalPath}">&times;</span>
                        `;
                        thumbnailItem.appendChild(markInfoDiv);

                        // Attach event listener for the delete button
                        const deleteButton = markInfoDiv.querySelector('.delete-mark-button');
                        deleteButton.addEventListener('click', async (e) => { // Make this async
                            e.stopPropagation(); // Prevent opening image or folder when clicking delete
                            const pathToDelete = e.target.dataset.path;
                            const scrollPos = thumbnailsGridContainer.scrollTop; // Capture scroll position
                            if (window.electronAPI && pathToDelete) {
                                await window.electronAPI.clearImageMarksForPath(pathToDelete);
                                imageMarks = await window.electronAPI.getImageMarks(); // Reload marks
                                updatePlaybackImagePool(); // Also update the playback pool for main menu
                                await renderCurrentPageThumbnails(); // NOW AWAIT IT to ensure DOM is fully rebuilt
                                // FIX: Defer scroll restoration slightly to allow DOM to render
                                requestAnimationFrame(() => {
                                    thumbnailsGridContainer.scrollTop = scrollPos; // Restore scroll position
                                });
                                updateMainMenuHintText(); // Update hint text when marks are changed
                            }
                        });
                    }

                    // Add double-click to open image in system viewer
                    thumbnailItem.addEventListener('dblclick', () => {
                        if (window.electronAPI && item.originalPath) {
                            console.log(`Renderer: Double-clicked to open file: ${item.originalPath}`); // Debug log
                            window.electronAPI.openFileInDefaultApp(item.originalPath)
                                .then(result => {
                                    if (!result.success) {
                                        showCustomAlert(result.message || '无法打开文件。', '错误');
                                        console.error('Renderer: Failed to open file in default app:', result.message || 'Unknown error'); // Debug log
                                    } else {
                                        console.log('Renderer: File opened successfully.'); // Debug log
                                    }
                                });
                        } else {
                            showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
                        }
                    });
                }
                thumbnailsGridContainer.appendChild(thumbnailItem);
            }

            // Update pagination info and button states
            const totalPages = Math.ceil(currentFolderItems.length / itemsPerPage);
            pageInfoDisplay.textContent = `第 ${currentPage + 1} 页 / 共 ${totalPages === 0 ? 1 : totalPages} 页`;
            prevPageButton.disabled = (currentPage === 0);
            nextPageButton.disabled = (currentPage >= totalPages - 1 || totalPages === 0);
        }

        /**
         * Displays the previous page of thumbnails.
         */
        function showPreviousPageOfThumbnails() {
            if (currentPage > 0) {
                currentPage--;
                renderCurrentPageThumbnails();
            }
        }

        /**
         * Displays the next page of thumbnails.
         */
        function showNextPageOfThumbnails() {
            const totalPages = Math.ceil(currentFolderItems.length / itemsPerPage);
            if (currentPage < totalPages - 1) {
                currentPage++;
                renderCurrentPageThumbnails();
            }
        }

        /**
         * Display folder browser view and load images and subfolders under the specified path
         * @param {string} folderPath - 要读取的文件夹路径。如果为空，则打开文件选择对话框。
         */
        async function showFolderBrowserView(folderPath) {
            if (!folderPath) {
                // If no path is provided, open folder selection dialog
                if (window.electronAPI) {
                    const newFolderPath = await window.electronAPI.openFolderDialog(currentDefaultImageFolderPath || undefined);
                    if (newFolderPath) {
                        folderPath = newFolderPath;
                    } else {
                        showMainMenu(); // User canceled selection, return to main menu
                        return;
                    }
                } else {
                    showCustomAlert('无法加载图片库，请选择一个有效文件夹。', '错误');
                    showMainMenu(); // Go back to main menu for user to re-select
                    return;
                }
            }

            controlsMenu.classList.add('hidden');
            imageDisplayArea.classList.add('hidden');
            folderBrowserView.classList.remove('hidden'); // Show image library view
            topRightMenuButtons.classList.remove('hidden'); // Show top-right menu buttons in folder browser view

            // Ensure the dynamic layer is not showing its background for folder browser
            dynamicBackgroundLayer.style.backgroundImage = 'none';
            dynamicBackgroundLayer.style.backgroundColor = 'transparent';
            dynamicBackgroundLayer.classList.remove('grayscale-active-bg'); // Ensure grayscale is off for this layer
            updateMainMenuBackground(); // Image library view also uses main menu background (on body)
            
            currentLoadedFolderPath = folderPath; // Update current loaded folder path
            // Simplify path display, only show the last part of the folder name, but keep full path as tooltip
            const pathParts = folderPath.split(/[/\\]/);
            currentLibraryPathDisplay.textContent = `当前文件夹: ${pathParts[pathParts.length - 1]}`;
            currentLibraryPathDisplay.title = folderPath; // Full path as tooltip
            
            thumbnailsGridContainer.innerHTML = ''; // Clear previous thumbnails
            folderBrowserInfoMessage.textContent = '加载中...'; // Display loading message
            folderBrowserInfoMessage.classList.remove('hidden'); // Ensure message is displayed

            // Clear global image data, wait for re-population
            imageFiles = []; 
            imageUrls = [];
            currentFolderItems = []; // Clear for pagination display as well
            
            // Disable "Select this folder" button by default until images are loaded
            selectFolderForSketchAndReturnToMenuButton.disabled = true;

            // Show "Go Up Folder" button (if not root directory)
            const parentPath = getParentPath(folderPath);
            goUpFolderButton.classList.toggle('hidden', !parentPath);

            // Update the library filter button state
            libraryFilterMarkedToggle.classList.toggle('active', isLibraryFilterMarkedEnabled);

            try {
                const items = await window.electronAPI.readFolderImages(folderPath);

                if (items.length === 0) {
                    folderBrowserInfoMessage.textContent = `在 "${pathParts[pathParts.length - 1]}" 文件夹中未找到任何图片或子文件夹。`;
                    await renderCurrentPageThumbnails(); // Update pagination UI to reflect empty state
                    return;
                }

                const directories = items.filter(item => item.type === 'directory');
                let allImageFilesForPlayback = items.filter(item => item.type === 'file');

                // Apply library filter here for display
                if (isLibraryFilterMarkedEnabled) {
                    allImageFilesForPlayback = allImageFilesForPlayback.filter(file => {
                        const isMarked = imageMarks[file.originalPath] && imageMarks[file.originalPath].length > 0;
                        return !isMarked; // Only keep unmarked images
                    });
                }


                // Sort image files for sequential playback
                allImageFilesForPlayback.sort((a, b) => naturalSort(a, b)); // Pass whole object for naturalSort

                // Populate global image data for sketch mode (ONLY images, and sorted)
                imageFiles = allImageFilesForPlayback.map(file => ({ name: file.name, path: file.originalPath }));
                imageUrls = allImageFilesForPlayback.map(file => file.path);

                // NEW: Update the playback image pool after loading files
                updatePlaybackImagePool();

                // Combine all items (directories + sorted images) for pagination display
                currentFolderItems = directories.concat(allImageFilesForPlayback);
                currentFolderItems.sort((a,b) => { // Sort all items (folders first, then files)
                    if (a.type === 'directory' && b.type === 'file') return -1;
                    if (a.type === 'file' && b.type === 'directory') return 1;
                    return naturalSort(a,b);
                });


                currentPage = 0; // Reset to first page
                await renderCurrentPageThumbnails(); // Wait for thumbnails to render including folder completion checks

                if (imageUrls.length > 0) {
                    selectFolderForSketchAndReturnToMenuButton.disabled = false; // Enable "Select this folder" only if there are images
                } else {
                    selectFolderForSketchAndReturnToMenuButton.disabled = true; // Disable if no images
                }
                updateMainMenuHintText(); // Update hint text after loading folder content

            }  catch (error) {
                console.error('Failed to load images/folders for folder browser:', error);
                folderBrowserInfoMessage.textContent = `加载图片库失败：${error.message || '未知错误'}`;
                folderBrowserInfoMessage.classList.remove('hidden');
                selectFolderForSketchAndReturnToMenuButton.disabled = true; // Disable on failure
                await renderCurrentPageThumbnails(); // Update pagination UI for error state
            }
            // Show traffic lights when in folder browser
            if (window.electronAPI) {
                window.electronAPI.setTrafficLightVisibility(true);
            }
        }

        /**
         * Get parent folder path
         * @param {string} currentPath - Current path
         * @returns {string|null} Parent path, null if it's the root directory
         */
        function getParentPath(currentPath) {
            if (!currentPath) return null;
            // Use Electron API to get dirname, because renderer process does not have Node.js path module
            // Currently simplified to JS string operations, but a more robust solution is IPC to main process to get path.dirname
            const parts = currentPath.split(/[/\\]/); // Compatible with Windows and macOS
            if (parts.length <= 1) return null; // Already root directory or drive root (e.g., C:\)

            // If it's Windows drive root (e.g., C:\), there is no parent
            if (parts.length === 2 && parts[1] === '' && /^[a-zA-Z]:$/.test(parts[0])) {
                return null;
            }
            
            // Remove the last part
            parts.pop();
            // Recombine path
            let parent = parts.join(currentPath.includes('/') ? '/' : '\\');
            // Handle Windows drive root, ensure C: becomes C:\
            if (parent.match(/^[a-zA-Z]:$/) && currentPath.includes('\\')) {
                parent += '\\';
            }
            return parent || (currentPath.includes('/') ? '/' : '\\'); // If it's /a/b -> / , otherwise Windows drive root
        }


        /**
         * Helper function: Converts Hex color to RGBA string
         * @param {string} hex - Hex color value (e.g., #RRGGBB)
         * @param {number} alpha - Alpha transparency (0-1)
         * @returns {string} - RGBA color string (e.g., rgba(255, 255, 255, 0.3))
         */
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        /**
         * Sets grid color and saves to settings.
         * @param {string} hexColor - Hex color value to set.
         */
        function setGridColor(hexColor) {
            currentGridColorHex = hexColor;
            ctx.strokeStyle = hexToRgba(currentGridColorHex, gridAlpha);
            if (window.electronAPI) {
                window.electronAPI.saveSetting('gridColor', currentGridColorHex);
            }
            if (isGridEnabled && !imageDisplayArea.classList.contains('hidden')) {
                drawGrid();
            }
        }

        /**
         * Sets grid size and saves to settings.
         * @param {number} size - Grid size (pixels).
         */
        function setGridSize(size) {
            currentGridSize = size;
            if (window.electronAPI) {
                window.electronAPI.saveSetting('gridSize', currentGridSize);
            }
            if (isGridEnabled && !imageDisplayArea.classList.contains('hidden')) {
                drawGrid();
            }
        }

        /**
         * Sets time display format and saves to settings.
         * @param {string} format - Time format ('hours:minutes:seconds' or 'seconds').
         */
        function setTimeFormat(format) {
            currentTimeFormat = format;
            if (window.electronAPI) {
                window.electronAPI.saveSetting('timeFormat', currentTimeFormat);
            }
            updateCountdownDisplay(); // Update display immediately
        }

        /**
         * Initialization function, loads all saved settings and determines initial view.
         */
        document.addEventListener('DOMContentLoaded', async () => {
            if (window.electronAPI) {
                // Load theme setting first
                isLightThemeEnabled = await window.electronAPI.loadSetting('isLightThemeEnabled') ?? false; // Default to dark theme
                applyTheme(isLightThemeEnabled); // Apply theme immediately

                // Load main menu background settings
                mainMenuBackgroundChoice = await window.electronAPI.loadSetting('mainMenuBackgroundChoice') ?? 'solidColor';
                currentMainMenuBackgroundPath = await window.electronAPI.loadSetting('mainMenuBackgroundPath') || '';
                
                mainMenuBackgroundChoiceRadios.forEach(radio => {
                    if (radio.value === mainMenuBackgroundChoice) {
                        radio.checked = true;
                    }
                });
                mainMenuStaticImagePathRow.style.display = (mainMenuBackgroundChoice === 'staticImage') ? 'flex' : 'none';
                mainMenuBackgroundPathDisplay.value = currentMainMenuBackgroundPath || '未选择静态图片';


                // Load preview background settings
                previewBackgroundChoice = await window.electronAPI.loadSetting('previewBackgroundChoice') ?? 'solidColor'; // Default to 'solidColor'
                currentPreviewBackgroundPath = await window.electronAPI.loadSetting('previewBackgroundPath') || ''; // Path for 'staticImage' mode

                previewBackgroundChoiceRadios.forEach(radio => {
                    if (radio.value === previewBackgroundChoice) {
                        radio.checked = true;
                    }
                });
                // Initialize visibility of staticImagePathRow
                staticImagePathRow.style.display = (previewBackgroundChoice === 'staticImage') ? 'flex' : 'none';
                previewBackgroundPathDisplay.value = currentPreviewBackgroundPath || '未选择静态图片';
                
                // Load grid color
                const savedGridColor = await window.electronAPI.loadSetting('gridColor');
                if (savedGridColor) {
                    gridColorPicker.value = savedGridColor;
                    setGridColor(savedGridColor); 
                } else {
                    gridColorPicker.value = defaultGridColorHex;
                    setGridColor(defaultGridColorHex);
                }

                // Load grid size
                const savedGridSize = await window.electronAPI.loadSetting('gridSize');
                if (savedGridSize) {
                    gridSizeInput.value = savedGridSize;
                    setGridSize(savedGridSize); 
                } else {
                    gridSizeInput.value = defaultGridSize;
                    setGridSize(defaultGridSize);
                }

                // Load time format
                const savedTimeFormat = await window.electronAPI.loadSetting('timeFormat');
                if (savedTimeFormat) {
                    currentTimeFormat = savedTimeFormat;
                    // Ensure the correct radio button is checked even if the value changed
                    timeFormatRadios.forEach(radio => {
                        if (radio.value === savedTimeFormat) {
                            radio.checked = true;
                        } else {
                             // Handle old "minutes:seconds" format by mapping it to "hours:minutes:seconds"
                            if (savedTimeFormat === "minutes:seconds" && radio.value === "hours:minutes:seconds") {
                                radio.checked = true;
                                currentTimeFormat = "hours:minutes:seconds"; // Update internal state
                            }
                        }
                    });
                    setTimeFormat(currentTimeFormat); // Call setTimeFormat with the potentially updated format
                } else {
                    currentTimeFormat = defaultTimeFormat;
                    timeFormatRadios.forEach(radio => {
                        if (radio.value === defaultTimeFormat) {
                            radio.checked = true;
                        }
                    });
                    setTimeFormat(defaultTimeFormat);
                }

                // Load default image folder path
                currentDefaultImageFolderPath = await window.electronAPI.loadSetting('defaultImageFolderPath') || '';
                defaultImageFolderPathDisplay.value = currentDefaultImageFolderPath || '未设置默认路径';

                // Load random playback setting
                isRandomPlayback = await window.electronAPI.loadSetting('isRandomPlayback') ?? true; // Default to true if not set
                randomPlaybackToggle.classList.toggle('active', isRandomPlayback);
                console.log('Random playback button listener attached. Initial state:', isRandomPlayback); // Listener attachment log

                // Load filter marked setting (for playback)
                isFilterMarkedEnabled = await window.electronAPI.loadSetting('isFilterMarkedEnabled') ?? true; // Default to true (filter marked)
                filterMarkedToggle.classList.toggle('active', isFilterMarkedEnabled);
                console.log('Filter marked button listener attached. Initial state:', isFilterMarkedEnabled); // Listener attachment log

                // Load library filter marked setting
                isLibraryFilterMarkedEnabled = await window.electronAPI.loadSetting('isLibraryFilterMarkedEnabled') ?? false; // Default to false (show all)
                libraryFilterMarkedToggle.classList.toggle('active', isLibraryFilterMarkedEnabled);

                // Load always on top setting
                isAlwaysOnTop = await window.electronAPI.loadSetting('isAlwaysOnTop') ?? false; // Default to false
                // Update both buttons here
                mainMenuAlwaysOnTopToggle.classList.toggle('active', isAlwaysOnTop);
                toggleAlwaysOnTopButton.classList.toggle('active', isAlwaysOnTop);

                // New: Load image marks
                imageMarks = await window.electronAPI.getImageMarks();


                // Determine initial view based on default image folder
                if (currentDefaultImageFolderPath) {
                    showFolderBrowserView(currentDefaultImageFolderPath); // Display image library view and load default images
                } else {
                    showMainMenu(); // Display main menu
                }

            } else {
                // If not in Electron environment, use default values and show main menu
                applyTheme(false); // Default to dark theme
                mainMenuBackgroundChoice = 'solidColor'; // Default for non-Electron
                currentMainMenuBackgroundPath = ''; // Default for non-Electron
                previewBackgroundChoice = 'solidColor'; // Preview background defaults to empty
                currentPreviewBackgroundPath = '';
                gridColorPicker.value = defaultGridColorHex;
                setGridColor(defaultGridColorHex);
                gridSizeInput.value = defaultGridSize;
                setGridSize(defaultGridSize);
                currentTimeFormat = defaultTimeFormat;

                // Set radio buttons for non-Electron defaults
                mainMenuBackgroundChoiceRadios.forEach(radio => {
                    if (radio.value === mainMenuBackgroundChoice) {
                        radio.checked = true;
                    }
                });
                previewBackgroundChoiceRadios.forEach(radio => {
                    if (radio.value === previewBackgroundChoice) {
                        radio.checked = true;
                    }
                });

                mainMenuStaticImagePathRow.style.display = 'none'; // Hide if not Electron
                staticImagePathRow.style.display = 'none'; // Hide if not Electron

                showMainMenu(); // Show main menu by default in non-Electron environment
            }

            // Initialize main menu button states
            mirrorToggle.classList.toggle('active', isMirrorEnabled);
            grayscaleToggle.classList.toggle('active', isGrayscaleEnabled);
            gridToggle.classList.toggle('active', isGridEnabled);
            overlayMirrorToggle.classList.toggle('active', isMirrorEnabled);
            overlayGrayscaleToggle.classList.toggle('active', isGrayscaleEnabled);
            overlayGridToggle.classList.toggle('active', isGridEnabled); /* Fixed typo here */

            // Initialize preset time buttons
            displayTime = 60; // Ensure displayTime is initialized for updatePresetTimeButtons
            updatePresetTimeButtons(displayTime); // Call with initial displayTime value
        });

        /**
         * Handles folder selection event from Main Menu via the new custom button.
         */
        sketchFolderInputDisplay.addEventListener('click', async () => {
            if (window.electronAPI) {
                // When opening folder selection dialog, default to current loaded path or default path
                const folderPath = await window.electronAPI.openFolderDialog(currentLoadedFolderPath || currentDefaultImageFolderPath || undefined);
                if (folderPath) {
                    showFolderBrowserView(folderPath); // Navigate to image library view and load
                } else {
                    // User canceled selection, do nothing (keep silent)
                }
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
        });


        /**
         * Starts the sketch session.
         * Validates settings, hides the menu, displays the image area, and starts playback.
         * This function is now also called from advanceImage and when starting from the main menu.
         */
        function initiateSketchSession() {
            // displayTime is now controlled directly by preset button clicks,
            // or potentially from input field.
            // When infinite time is chosen, displayTime will be Infinity.
            if (displayTime !== Infinity && (isNaN(displayTime) || displayTime <= 0)) {
                showCustomAlert('请设置一个有效的图片显示时间 (大于0的整数)。', '时间设置错误');
                return;
            }
            
            // IMPORTANT: Re-populate the playback image pool to ensure the latest filter setting is applied
            // This is crucial if the filter was changed while in main menu, or after folder selection.
            updatePlaybackImagePool(); 

            if (currentPlaybackImageIndexes.length === 0) {
                // The tooltip on the start button should already indicate why it's disabled.
                // An alert here might be redundant but can be kept as a secondary feedback for non-Electron or specific errors.
                let errorMessage = '没有可供播放的图片。请选择一个图片文件夹或调整筛选设置。';
                let errorTitle = '图片缺失错误';

                if (imageUrls.length > 0 && isFilterMarkedEnabled) {
                    // If images were loaded but all are filtered out by marking
                    errorMessage = '该文件夹下图片已全部标记';
                    errorTitle = '播放结束';
                } else if (imageUrls.length === 0) {
                    // No images loaded at all (no folder selected or empty folder)
                    errorMessage = '没有可供播放的图片。请先在图片库中选择一个文件夹。';
                    errorTitle = '图片缺失错误';
                }

                showCustomAlert(errorMessage, errorTitle);
                stopGame(); // Stop the session if no images are available in the filtered pool
                return;
            }

            // Hide traffic lights when starting sketch session
            if (window.electronAPI) {
                window.electronAPI.setTrafficLightVisibility(false);
            }

            // Reset image history (should only contain indices from currentPlaybackImageIndexes)
            displayedImageHistory = [];
            historyPointer = -1;
            isPaused = false; // Ensure not paused when starting
            pausePlayButton.textContent = '⏸'; // Reset button icon to Pause

            controlsMenu.classList.add('hidden');
            folderBrowserView.classList.add('hidden');
            imageDisplayArea.classList.remove('hidden'); // Show image display area
            topRightMenuButtons.classList.add('hidden'); // Hide top-right menu buttons during playback
            
            // Clear background from body and apply to dynamic layer
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = 'transparent';
            updatePreviewBackground(); // Unified background update for dynamicBackgroundLayer
            updatePreviewBackgroundGrayscaleEffect(); // Ensure grayscale is applied to dynamicBackgroundLayer if enabled

            isPlaying = true;
            
            // Start with an image from the available (filtered) list
            advanceImage(true, false); // Pass true for isStartingNewSession, filteredIndexes is now implicitly handled
            updateNavigationButtons(); 
        }

        // Main menu start button now calls unified initiateSketchSession
        startButton.addEventListener('click', initiateSketchSession);
        // "Select this folder" button in image library view now returns to main menu and sets path
        selectFolderForSketchAndReturnToMenuButton.addEventListener('click', () => {
            showMainMenu(currentLoadedFolderPath); // Return to main menu and pass current loaded folder path
        });


        /**
         * Sets preset time and updates the input field.
         * Also handles the active state of buttons.
         * @param {number} time - Preset time (seconds or Infinity).
         * @param {HTMLElement} [activeButton] - The currently clicked button element. If not provided, it's inferred.
         */
        function setPresetTime(time, activeButton = null) {
            displayTime = time;
            
            // When infinite time is selected, disable the number input and clear its value
            // The '∞' symbol will be shown in the countdown display instead.
            if (time === Infinity) {
                displayTimeInput.value = ''; // Clear value
                displayTimeInput.disabled = true;
            } else {
                displayTimeInput.value = time;
                displayTimeInput.disabled = false;
            }
            
            updatePresetTimeButtons(time, activeButton);
            updateMainMenuHintText(); // Update hint text when display time changes
        }

        /**
         * Updates the active and disabled state of preset time buttons based on the current displayTime.
         * This function ensures that only one preset button is active at a time, and that the numeric input
         * reflects the currently selected preset or a custom value. It also manages the disabled state
         * of the numeric input based on whether 'Infinity' is selected.
         * @param {number} currentDisplayTimeValue - The current value of displayTime (seconds or Infinity).
         * @param {HTMLElement} [clickedButton=null] - The button that was just clicked, if any.
         */
        function updatePresetTimeButtons(currentDisplayTimeValue, clickedButton = null) {
            const presetButtons = presetTimeButtonsContainer.querySelectorAll('.toggle');
            
            // Remove 'active' and 'disabled-preset' from all buttons first
            presetButtons.forEach(btn => {
                btn.classList.remove('active', 'disabled-preset');
            });

            if (clickedButton) {
                // If a button was explicitly clicked, activate it
                clickedButton.classList.add('active');
            } else {
                // If the change came from the input field or initial load, find the matching preset
                // and activate it.
                let matched = false;
                presetButtons.forEach(btn => {
                    // Safely parse textContent, handling '∞'
                    const presetValue = (btn.id === 'presetInfiniteTime') ? Infinity : parseInt(btn.textContent, 10);
                    if (currentDisplayTimeValue === presetValue) {
                        btn.classList.add('active');
                        matched = true;
                    }
                });
            }

            // Ensure the number input field is enabled/disabled correctly based on whether 'Infinity' is selected.
            // This is also handled in setPresetTime, but explicitly setting it here for robustness
            displayTimeInput.disabled = (currentDisplayTimeValue === Infinity);
        }

        // Input event listener for displayTimeInput
        displayTimeInput.addEventListener('input', (event) => {
            const inputValue = event.target.value;
            // When user types in the number input, it's always a finite number.
            const numValue = parseInt(inputValue, 10);
            if (!isNaN(numValue) && numValue >= 1) { 
                displayTime = numValue;
            } else if (inputValue === '') { // Allow empty input temporarily (e.g., user is typing)
                displayTime = NaN; // Set to NaN or some indicator of invalid state
            }
            // If the input is not a valid number, we don't update displayTime,
            // so the last valid displayTime remains, or it becomes NaN.
            // The preset buttons logic will handle their activation based on the actual displayTime.

            updatePresetTimeButtons(displayTime); 
            updateMainMenuHintText(); 
        });


        /**
         * Opens the settings modal.
         */
        settingsButton.addEventListener('click', () => {
            settingsModalOverlay.classList.add('active');
        });

        /**
         * Closes the settings modal.
         */
        closeSettingsModalButton.addEventListener('click', () => {
            settingsModalOverlay.classList.remove('active');
        });

        /**
         * Toggles random/sequential playback.
         */
        randomPlaybackToggle.addEventListener('click', async () => {
            console.log('Random playback button clicked!'); // Log click event
            isRandomPlayback = !isRandomPlayback;
            randomPlaybackToggle.classList.toggle('active', isRandomPlayback);
            console.log('isRandomPlayback state after toggle:', isRandomPlayback); // Log new state
            if (window.electronAPI) {
                await window.electronAPI.saveSetting('isRandomPlayback', isRandomPlayback);
            }
            // If in playback mode, changing this will affect the NEXT image's selection.
            // No need to stop and restart immediately, as advanceImage already checks isRandomPlayback.
        });

        /**
         * Toggles filtering of marked images (for playback).
         */
        filterMarkedToggle.addEventListener('click', async () => {
            console.log('Filter marked button clicked!'); // Log click event
            isFilterMarkedEnabled = !isFilterMarkedEnabled;
            filterMarkedToggle.classList.toggle('active', isFilterMarkedEnabled);
            console.log('isFilterMarkedEnabled state after toggle:', isFilterMarkedEnabled); // Log new state
            if (window.electronAPI) {
                await window.electronAPI.saveSetting('isFilterMarkedEnabled', isFilterMarkedEnabled);
            }
            // Always update the image pool when filter setting changes
            updatePlaybackImagePool();
            updateMainMenuHintText(); // Update hint text when filter changes

            // If currently in playback mode, stop and restart to apply the new filter immediately
            // If not playing, or in the main menu, the next 'Start Sketch' will use the updated pool.
            if (isPlaying) {
                stopGame(); // Stop current playback
                showCustomAlert('已更新图片筛选设置。请重新开始速写。', '设置更新');
            }
        });

        /**
         * Toggles between light and dark themes (from settings modal).
         */
        settingsModalThemeToggle.addEventListener('click', () => {
            applyTheme(!isLightThemeEnabled); // Toggle the theme
        });

        // Event listener for main menu background choice radios
        mainMenuBackgroundChoiceRadios.forEach(radio => {
            radio.addEventListener('change', async (event) => {
                mainMenuBackgroundChoice = event.target.value;
                if (window.electronAPI) {
                    await window.electronAPI.saveSetting('mainMenuBackgroundChoice', mainMenuBackgroundChoice);
                }
                mainMenuStaticImagePathRow.style.display = (mainMenuBackgroundChoice === 'staticImage') ? 'flex' : 'none';
                // Only update background if currently in main menu or folder browser mode
                if (controlsMenu.classList.contains('hidden') && folderBrowserView.classList.contains('hidden')) {
                    // Is in image display area, do nothing
                } else { 
                    updateMainMenuBackground();
                }
                if (mainMenuBackgroundChoice === 'staticImage') {
                    mainMenuBackgroundPathDisplay.value = currentMainMenuBackgroundPath || '未选择静态图片';
                }
            });
        });

        /**
         * Handles selecting a static image for main menu background.
         */
        selectMainMenuImageButton.addEventListener('click', async () => {
            if (window.electronAPI) {
                const filePath = await window.electronAPI.openFileDialog();
                if (filePath) {
                    currentMainMenuBackgroundPath = filePath;
                    mainMenuBackgroundPathDisplay.value = filePath;
                    await window.electronAPI.saveSetting('mainMenuBackgroundPath', currentMainMenuBackgroundPath);
                    // Only update background if currently in main menu or folder browser mode
                    if (controlsMenu.classList.contains('hidden') && folderBrowserView.classList.contains('hidden')) {
                        // Is in image display area, do nothing
                    } else { 
                        updateMainMenuBackground();
                    }
                    showCustomAlert('主菜单静态图片背景已更新并保存。', '背景设置');
                }
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
        });

        /**
         * Clears the selected static image for main menu background.
         */
        clearMainMenuImageButton.addEventListener('click', async () => {
            currentMainMenuBackgroundPath = '';
            mainMenuBackgroundPathDisplay.value = '未选择静态图片';
            if (window.electronAPI) {
                await window.electronAPI.saveSetting('mainMenuBackgroundPath', '');
            }
            // Only update background if currently in main menu or folder browser mode
            if (controlsMenu.classList.contains('hidden') && folderBrowserView.classList.contains('hidden')) {
                // Is in image display area, do nothing
            } else { 
                updateMainMenuBackground();
            }
            showCustomAlert('主菜单静态图片背景已清除，将显示纯色背景。', '背景设置');
        });


        // Event listener for preview background choice radios
        previewBackgroundChoiceRadios.forEach(radio => {
            radio.addEventListener('change', async (event) => {
                previewBackgroundChoice = event.target.value;
                if (window.electronAPI) {
                    await window.electronAPI.saveSetting('previewBackgroundChoice', previewBackgroundChoice);
                }
                // Show/hide staticImagePathRow based on selection
                staticImagePathRow.style.display = (previewBackgroundChoice === 'staticImage') ? 'flex' : 'none';

                // If currently in preview mode, immediately update background based on new choice
                if (!imageDisplayArea.classList.contains('hidden')) {
                    updatePreviewBackground(); // This will handle applying solid, static or average color background
                    updatePreviewBackgroundGrayscaleEffect(); // Also update grayscale effect for background
                }
                
                // If switching away from staticImage, clear the path in memory (but not from storage immediately)
                // This ensures "纯色" behaves as expected and "平均色" doesn't try to use an old path.
                if (previewBackgroundChoice !== 'staticImage') {
                    // currentPreviewBackgroundPath = ''; // Don't clear from memory, keep it for next time user selects static image
                } else {
                    // When switching TO staticImage, ensure path display is correct
                    previewBackgroundPathDisplay.value = currentPreviewBackgroundPath || '未选择静态图片';
                }
            });
        });

        /**
         * Handles selecting a static image for preview background.
         */
        selectStaticImageButton.addEventListener('click', async () => {
            if (window.electronAPI) {
                const filePath = await window.electronAPI.openFileDialog();
                if (filePath) {
                    currentPreviewBackgroundPath = filePath;
                    previewBackgroundPathDisplay.value = filePath;
                    await window.electronAPI.saveSetting('previewBackgroundPath', currentPreviewBackgroundPath);
                    if (!imageDisplayArea.classList.contains('hidden') && previewBackgroundChoice === 'staticImage') {
                        applyBackground(dynamicBackgroundLayer, 'staticImage', currentPreviewBackgroundPath);
                    }
                    showCustomAlert('静态图片背景已更新并保存。', '背景设置');
                } else {
                    // User canceled selection, do nothing
                }
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
        });

        /**
         * Clears the selected static image for preview background.
         * This effectively makes it "pure color" again (default themed solid).
         */
        clearStaticImageButton.addEventListener('click', async () => {
            currentPreviewBackgroundPath = '';
            previewBackgroundPathDisplay.value = '未选择静态图片';
            if (window.electronAPI) {
                await window.electronAPI.saveSetting('previewBackgroundPath', '');
            }
            if (!imageDisplayArea.classList.contains('hidden') && previewBackgroundChoice === 'staticImage') {
                applyBackground(dynamicBackgroundLayer, 'previewSolid'); // Apply default solid color
            }
            showCustomAlert('静态图片背景已清除，将显示纯色背景。', '背景设置');
        });


        /**
         * Set default image folder path
         */
        setDefaultImageFolderButton.addEventListener('click', async () => {
            if (window.electronAPI) {
                // When opening folder selection dialog, default to current set path
                const folderPath = await window.electronAPI.openFolderDialog(currentDefaultImageFolderPath || undefined);
                if (folderPath) {
                    currentDefaultImageFolderPath = folderPath;
                    await window.electronAPI.saveSetting('defaultImageFolderPath', folderPath);
                    defaultImageFolderPathDisplay.value = folderPath;
                    showCustomAlert('默认图片文件夹路径已设置并保存。下次启动将自动加载。', '默认路径设置');
                    // After setting, if currently in main menu or image library, should refresh image library view to display new default path content
                    if (!controlsMenu.classList.contains('hidden') || !folderBrowserView.classList.contains('hidden')) {
                        showFolderBrowserView(currentDefaultImageFolderPath);
                    }
                } else {
                    // User canceled selection, do nothing (keep silent)
                }
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
        });

        /**
         * Clear default image folder path
         */
        clearDefaultImageFolderButton.addEventListener('click', async () => {
            currentDefaultImageFolderPath = '';
            await window.electronAPI.saveSetting('defaultImageFolderPath', '');
            defaultImageFolderPathDisplay.value = '未设置默认路径';
            showCustomAlert('默认图片文件夹路径已清除。下次启动将显示主菜单。', '默认路径设置');
            // After clearing, if currently in image library view, should return to main menu
            if (!folderBrowserView.classList.contains('hidden')) {
                showMainMenu();
            }
        });

        /**
         * Grid color picker change event
         */
        gridColorPicker.addEventListener('input', (event) => {
            setGridColor(event.target.value); 
        });

        /**
         * Grid size input change event
         */
        gridSizeInput.addEventListener('input', (event) => {
            const size = parseInt(event.target.value, 10);
            if (!isNaN(size) && size >= 10 && size <= 200) { 
                setGridSize(size);
            } else {
                console.warn('Invalid grid size input.');
            }
        });

        /**
         * Resets grid color and size to default.
         */
        resetGridSettingsButton.addEventListener('click', () => {
            gridColorPicker.value = defaultGridColorHex;
            setGridColor(defaultGridColorHex);
            gridSizeInput.value = defaultGridSize;
            setGridSize(defaultGridSize);
            showCustomAlert('网格设置已重置为默认。', '网格设置');
        });

        /**
         * Time format radio button change event
         */
        timeFormatRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                setTimeFormat(event.target.value);
            });
        });

        /**
         * Toggles mirror effect.
         */
        function toggleMirrorEffect() {
            isMirrorEnabled = !isMirrorEnabled;
            currentImage.classList.toggle('mirror-effect', isMirrorEnabled);
            mirrorToggle.classList.toggle('active', isMirrorEnabled);
            overlayMirrorToggle.classList.toggle('active', isMirrorEnabled);
        }
        mirrorToggle.addEventListener('click', toggleMirrorEffect);
        overlayMirrorToggle.addEventListener('click', toggleMirrorEffect);

        /**
         * Toggles grayscale effect.
         */
        function toggleGrayscaleEffect() {
            isGrayscaleEnabled = !isGrayscaleEnabled;
            currentImage.classList.toggle('grayscale-effect', isGrayscaleEnabled);
            grayscaleToggle.classList.toggle('active', isGrayscaleEnabled);
            overlayGrayscaleToggle.classList.toggle('active', isGrayscaleEnabled);
            updatePreviewBackgroundGrayscaleEffect(); // <--- Update background grayscale
        }
        grayscaleToggle.addEventListener('click', toggleGrayscaleEffect);
        overlayGrayscaleToggle.addEventListener('click', toggleGrayscaleEffect);

        /**
         * Toggles grid overlay effect.
         */
        function toggleGridEffect() {
            isGridEnabled = !isGridEnabled;
            gridCanvas.classList.toggle('active', isGridEnabled);
            gridToggle.classList.toggle('active', isGridEnabled);
            overlayGridToggle.classList.toggle('active', isGridEnabled);
            if (isGridEnabled) {
                if (currentImage.complete && currentImage.naturalWidth > 0) { // Check naturalWidth for fully loaded
                    drawGrid();
                }
            } else {
                ctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); 
            }
        }
        gridToggle.addEventListener('click', toggleGridEffect);
        overlayGridToggle.addEventListener('click', toggleGridEffect);

        /**
         * Toggles window always-on-top status.
         * Updates both the main menu button and the overlay button.
         */
        function toggleAlwaysOnTop() {
            isAlwaysOnTop = !isAlwaysOnTop;
            if (window.electronAPI) { 
                window.electronAPI.setAlwaysOnTop(isAlwaysOnTop);
                // Also save the setting for persistence
                window.electronAPI.saveSetting('isAlwaysOnTop', isAlwaysOnTop);
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
            // Update both UI elements
            mainMenuAlwaysOnTopToggle.classList.toggle('active', isAlwaysOnTop);
            toggleAlwaysOnTopButton.classList.toggle('active', isAlwaysOnTop);
        }
        toggleAlwaysOnTopButton.addEventListener('click', toggleAlwaysOnTop);
        mainMenuAlwaysOnTopToggle.addEventListener('click', toggleAlwaysOnTop);

        // Listen for always-on-top status from main process to sync button state
        if (window.electronAPI) {
            window.electronAPI.onAlwaysOnTopStatus((status) => {
                isAlwaysOnTop = status;
                mainMenuAlwaysOnTopToggle.classList.toggle('active', isAlwaysOnTop);
                toggleAlwaysOnTopButton.classList.toggle('active', isAlwaysOnTop);
            });
        }

        /**
         * Opens the current image in Finder.
         */
        openInFinderButton.addEventListener('click', () => {
            if (window.electronAPI && currentImageIndex !== -1 && imageFiles[currentImageIndex] && imageFiles[currentImageIndex].path) {
                // Use originalPath to open file, because file:// URL cannot be directly used in Finder
                const currentFilePath = imageFiles[currentImageIndex].path; 
                window.electronAPI.openFileInFinder(currentFilePath);
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用，且需要选择图片文件夹。', '提示');
            }
        });

        // New: Mark Star button click handler
        markStarButton.addEventListener('click', async () => {
            if (window.electronAPI && currentImageIndex !== -1 && imageFiles[currentImageIndex]) {
                const filePath = imageFiles[currentImageIndex].path;
                const imageName = imageFiles[currentImageIndex].name; // Get image name

                // Check if current image is already marked
                const isMarked = imageMarks[filePath] && imageMarks[filePath].length > 0;

                if (isMarked) {
                    // If marked, clear all marks for this image
                    await window.electronAPI.clearImageMarksForPath(filePath);
                    // After clearing, reload marks and update playback pool (if filter is active)
                    imageMarks = await window.electronAPI.getImageMarks();
                    updatePlaybackImagePool(); // Re-calculate playback pool
                } else {
                    // If not marked, add a new mark
                    // For infinite mode, the duration is not relevant for auto-marking, but we still store it.
                    const duration = (displayTime === Infinity) ? 0 : displayTime; // Store 0 for infinite, actual duration otherwise
                    await window.electronAPI.saveImageMark(filePath, duration);
                    // After saving, reload marks and update playback pool (if filter is active)
                    imageMarks = await window.electronAPI.getImageMarks();
                    updatePlaybackImagePool(); // Re-calculate playback pool
                }
                updateMarkingUI(); // Update UI immediately
                updateMainMenuHintText(); // Update hint text when marking changes
                // Important: Re-render the folder browser view to update folder completion marks
                if (!folderBrowserView.classList.contains('hidden')) {
                    await showFolderBrowserView(currentLoadedFolderPath); 
                }
            } else {
                // Keep the alert for actual operation failure, not just UI feedback
                showCustomAlert('无法操作标记。请确保已选择图片文件夹并开始速写。', '操作失败');
            }
        });


        /**
         * Updates the UI related to image marking (icon state and tooltip).
         */
        function updateMarkingUI() {
            const markIconSpan = markStarButton.querySelector('.mark-icon'); // Get the span for icon
            if (currentImageIndex === -1 || !imageFiles[currentImageIndex]) {
                markStarButton.classList.remove('active'); // No active class
                markStarButton.setAttribute('data-tooltip', '未标记');
                return;
            }

            const currentImagePath = imageFiles[currentImageIndex].path;
            const marks = imageMarks[currentImagePath];

            if (marks && marks.length > 0) {
                markStarButton.classList.add('active'); // Add 'active' class to change background
                // Sort marks by timestamp to get the latest one
                marks.sort((a, b) => b.timestamp - a.timestamp);
                const latestMark = marks[0];
                const date = new Date(latestMark.timestamp);
                
                // Format timestamp into readable date/time (MM/DD)
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                const formattedDateShort = `${month}/${day}`;

                // Show "∞" for duration if it was marked in infinite mode (duration 0)
                const displayDuration = (latestMark.duration === 0) ? '∞' : `${latestMark.duration}s`;

                // Construct a detailed tooltip string in the requested format
                markStarButton.setAttribute('data-tooltip', `${formattedDateShort} (${displayDuration})`);
            } else {
                markStarButton.classList.remove('active'); // Remove 'active' class
                markStarButton.setAttribute('data-tooltip', '未标记');
            }
        }

        /**
         * Updates the global currentPlaybackImageIndexes array based on the filter setting.
         * This function should be called whenever the selected folder changes or the filter setting changes.
         */
        function updatePlaybackImagePool() {
            currentPlaybackImageIndexes = [];
            for (let i = 0; i < imageUrls.length; i++) {
                const filePath = imageFiles[i].path;
                // If filter is enabled AND image is marked, skip it
                if (isFilterMarkedEnabled && imageMarks[filePath] && imageMarks[filePath].length > 0) {
                    continue; 
                }
                currentPlaybackImageIndexes.push(i); // Add the raw index to the eligible list
            }
            // Sort the eligible indices based on the original file names for sequential playback consistency
            currentPlaybackImageIndexes.sort((a, b) => naturalSort(imageFiles[a], imageFiles[b])); // Pass whole object for naturalSort
            
            // Re-enable/disable start button based on the filtered list length
            startButton.disabled = (currentPlaybackImageIndexes.length === 0);

            // Update tooltip for the start button
            if (startButton.disabled) {
                if (imageUrls.length > 0 && isFilterMarkedEnabled && currentPlaybackImageIndexes.length === 0) {
                    // All images exist, filter is on, and all are marked
                    startButton.setAttribute('data-tooltip', '该文件夹下图片已全部标记');
                } else if (imageUrls.length > 0 && currentPlaybackImageIndexes.length === 0) {
                    // Images exist, filter is off, but still no playable images (e.g., all were already filtered out without marking)
                    // This case should ideally not happen if filtering is the *only* reason for empty pool and images exist.
                    // Fallback to a generic "no playable images"
                    startButton.setAttribute('data-tooltip', '没有可播放的图片');
                } else {
                    // No folder selected or empty folder
                    startButton.setAttribute('data-tooltip', '请选择速写文件夹');
                }
            } else {
                startButton.setAttribute('data-tooltip', '开始速写');
            }
            console.log(`Playback image pool updated. Filtered images count: ${currentPlaybackImageIndexes.length}. Total images: ${imageUrls.length}`);
        }

        /**
         * Formats total seconds into H:M:S, M:S, or S based on duration.
         * @param {number} totalSeconds - The total number of seconds.
         * @returns {string} - Formatted time string.
         */
        function formatTimeForHint(totalSeconds) {
            if (totalSeconds === Infinity) {
                return '无限制时间';
            } else if (totalSeconds < 60) {
                return `${totalSeconds}秒`;
            } else if (totalSeconds < 3600) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}分${seconds}秒`;
            } else {
                const hours = Math.floor(totalSeconds / 3600);
                const remainingMinutes = Math.floor((totalSeconds % 3600) / 60);
                const remainingSeconds = totalSeconds % 60;
                return `${hours}小时${remainingMinutes}分${remainingSeconds}秒`;
            }
        }

        /**
         * Updates the hint text in the main menu based on selected images and time.
         */
        function updateMainMenuHintText() {
            const numImages = currentPlaybackImageIndexes.length;
            let hintText = '';

            if (currentLoadedFolderPath && numImages > 0) {
                if (displayTime === Infinity) {
                    hintText = `当前一共选择了${numImages}张图片，时间设置为无限制。`;
                } else {
                    const estimatedTotalTimeSeconds = numImages * displayTime;
                    const formattedEstimatedTime = formatTimeForHint(estimatedTotalTimeSeconds);
                    hintText = `当前一共选择了${numImages}张图片，估计耗时${formattedEstimatedTime}。`;
                }
            } else if (currentLoadedFolderPath && numImages === 0 && imageUrls.length > 0 && isFilterMarkedEnabled) {
                // Folder selected, but all images are filtered out by marking
                hintText = '该文件夹下图片已全部标记。请调整过滤设置或选择其他文件夹。';
            } else if (currentLoadedFolderPath && numImages === 0 && imageUrls.length === 0) {
                 // Folder selected, but no images were found at all
                hintText = '当前文件夹中没有可速写的图片。';
            }
            else {
                hintText = '选择文件夹以开始速写。';
            }
            mainMenuHintText.textContent = hintText;
        }


        /**
         * Displays the next image in sequence or a random one, based on the playback mode.
         * This function handles both automatic advancement (from timer) and manual 'next' clicks.
         * It always operates on the `currentPlaybackImageIndexes` list.
         * @param {boolean} isStartingNewSession - True if this call initiates a new sketch session.
         * @param {boolean} isTimerTriggered - True if called by the timer (for auto-marking).
         */
        async function advanceImage(isStartingNewSession = false, isTimerTriggered = false) {
            // First, re-check currentPlaybackImageIndexes in case the image was marked/unmarked mid-session
            updatePlaybackImagePool(); 

            if (currentPlaybackImageIndexes.length === 0) {
                // Determine the specific error message
                let errorMessage = '没有可供播放的图片。请选择一个图片文件夹或调整筛选设置。';
                let errorTitle = '图片缺失错误';

                if (imageUrls.length > 0 && isFilterMarkedEnabled) {
                    // If images were loaded but all are filtered out by marking
                    errorMessage = '该文件夹下图片已全部标记';
                    errorTitle = '播放结束';
                } else if (imageUrls.length === 0) {
                    // No images loaded at all (no folder selected or empty folder)
                    errorMessage = '没有可供播放的图片。请先在图片库中选择一个文件夹。';
                    errorTitle = '图片缺失错误';
                }

                showCustomAlert(errorMessage, errorTitle);
                stopGame(); // Stop the session if no images are available in the filtered pool
                return;
            }

            // Only mark automatically if the timer triggered the advance (isTimerTriggered is true)
            // AND it's not infinite mode AND it's not a brand new session start or initial load.
            if (isTimerTriggered && currentImageIndex !== -1 && isPlaying && !isPaused && displayTime !== Infinity) {
                const finishedImagePath = imageFiles[currentImageIndex].path;
                const finishedDuration = displayTime;
                await window.electronAPI.saveImageMark(finishedImagePath, finishedDuration);
                imageMarks = await window.electronAPI.getImageMarks(); // Reload marks
                updatePlaybackImagePool(); // Crucial: Re-evaluate playback pool after marking
            }

            let newIndexRaw; // This will be the index in the original imageUrls array

            if (isStartingNewSession) {
                displayedImageHistory = []; // Clear history
                historyPointer = -1; // Reset pointer

                if (isRandomPlayback) {
                    newIndexRaw = currentPlaybackImageIndexes[Math.floor(Math.random() * currentPlaybackImageIndexes.length)];
                } else {
                    newIndexRaw = currentPlaybackImageIndexes[0]; // Always start from the first eligible image
                }
                displayedImageHistory.push(newIndexRaw);
                historyPointer = 0;

            } else { // Not starting a new session (timer tick or manual 'next' click)
                if (!isRandomPlayback) {
                    // Find the current image's index within the *current* filtered playback pool
                    const currentPlaybackIndexInPool = currentPlaybackImageIndexes.indexOf(currentImageIndex);
                    
                    if (currentPlaybackIndexInPool === -1 || historyPointer >= displayedImageHistory.length -1) {
                        // Case 1: Current image is no longer in the playback pool (e.g., just marked it).
                        // Or Case 2: We are at the end of the history.
                        // Find the next image in the *current* sorted playback pool.
                        let nextPlaybackIndex = (currentPlaybackIndexInPool + 1) % currentPlaybackImageIndexes.length;
                        // If we are at the end of the filtered list, wrap around to the beginning for sequential
                        newIndexRaw = currentPlaybackImageIndexes[nextPlaybackIndex % currentPlaybackImageIndexes.length];
                        
                        // If current image was not in pool, or we're at end of history,
                        // clear future history and add the new image
                        if (historyPointer < displayedImageHistory.length -1) {
                            displayedImageHistory = displayedImageHistory.slice(0, historyPointer + 1);
                        }
                        displayedImageHistory.push(newIndexRaw);
                        historyPointer = displayedImageHistory.length - 1;

                    } else {
                        // Normal sequential progression within history
                        historyPointer++;
                        newIndexRaw = displayedImageHistory[historyPointer];
                    }
                } else {
                    // Random playback: Pick a new random image from the filtered list
                    if (currentPlaybackImageIndexes.length === 1) {
                        newIndexRaw = currentPlaybackImageIndexes[0];
                    } else {
                        const previousRawIndex = currentImageIndex;
                        let tempNewIndexRaw;
                        do {
                            tempNewIndexRaw = currentPlaybackImageIndexes[Math.floor(Math.random() * currentPlaybackImageIndexes.length)];
                        } while (tempNewIndexRaw === previousRawIndex && currentPlaybackImageIndexes.length > 1);
                        newIndexRaw = tempNewIndexRaw;
                    }

                    // Truncate history if navigating back then picking random
                    if (historyPointer < displayedImageHistory.length - 1) {
                        displayedImageHistory = displayedImageHistory.slice(0, historyPointer + 1);
                    }
                    displayedImageHistory.push(newIndexRaw);
                    historyPointer = displayedImageHistory.length - 1;
                }
            }

            currentImageIndex = newIndexRaw;
            currentImage.src = imageUrls[currentImageIndex];
            updateImageDisplay(); // <--- Call this here to handle effects and average background
            remainingTime = displayTime; // remainingTime will be Infinity if displayTime is Infinity
            updateCountdownDisplay();
            updateNavigationButtons();
            updateMarkingUI();

            if (isPaused) {
                isPaused = false;
                pausePlayButton.textContent = '⏸';
            }
            startCountdown();
        }

        /**
         * Displays the previous image in history.
         * This function always navigates backward through the recorded history.
         */
        function showPreviousImage() {
            if (historyPointer > 0) {
                clearInterval(countdownTimer);
                historyPointer--;
                currentImageIndex = displayedImageHistory[historyPointer];
                currentImage.src = imageUrls[currentImageIndex];
                updateImageDisplay(); // <--- Call this here to handle effects and average background
                remainingTime = displayTime; // Reset time for a new image from history (can be Infinity)
                updateCountdownDisplay();
                updateMarkingUI(); // New: Update marking UI after image changes

                // Ensure playback state (resume if was paused, otherwise keep playing)
                if (!isPaused) { // Only restart countdown if not explicitly paused
                    startCountdown();
                }
            } else {
                showCustomAlert('已是第一张图片。', '播放提示'); // User-friendly message
            }
            updateNavigationButtons();
        }

        // Navigation button event listeners
        preset30sButton.addEventListener('click', (event) => setPresetTime(30, event.target));
        preset60sButton.addEventListener('click', (event) => setPresetTime(60, event.target));
        preset120sButton.addEventListener('click', (event) => setPresetTime(120, event.target));
        preset300sButton.addEventListener('click', (event) => setPresetTime(300, event.target)); 
        preset600sButton.addEventListener('click', (event) => setPresetTime(600, event.target)); 
        presetInfiniteTime.addEventListener('click', (event) => setPresetTime(Infinity, event.target)); // Event for infinite button

        // Main menu start button now calls unified initiateSketchSession
        startButton.addEventListener('click', initiateSketchSession);
        // "Select this folder" button in image library view now returns to main menu and sets path
        selectFolderForSketchAndReturnToMenuButton.addEventListener('click', () => {
            showMainMenu(currentLoadedFolderPath); // Return to main menu and pass current loaded folder path
        });

        // Navigation button event listeners
        prevImageButton.addEventListener('click', showPreviousImage);
        // Modified nextImageButton to NOT trigger auto-marking
        nextImageButton.addEventListener('click', () => advanceImage(false, false)); // Manual next click, not timer triggered

        /**
         * Toggles pause/play for the countdown.
         */
        function togglePausePlay() { // Renamed for clarity, logic is the same
            if (isPaused) {
                // Currently paused, click to play
                isPaused = false;
                pausePlayButton.textContent = '⏸'; // Switch to Pause icon
                startCountdown(); // Resume from current remainingTime
            } else {
                // Currently playing, click to pause
                isPaused = true;
                pausePlayButton.textContent = '▶'; // Switch to Play icon
                clearInterval(countdownTimer);
            }
            updateNavigationButtons(); 
        }
        pausePlayButton.addEventListener('click', togglePausePlay);


        /**
         * Starts the countdown.
         * This function now always uses the current 'remainingTime'.
         * 'remainingTime' is set to 'displayTime' only when a new image is loaded (in advanceImage).
         */
        function startCountdown() {
            clearInterval(countdownTimer); 
            // If in infinite mode, or explicitly paused, do not start the interval
            if (displayTime === Infinity || isPaused) { 
                return;
            }

            // remainingTime is already set by advanceImage, or it's the value from before pausing.
            updateCountdownDisplay(); // Update display immediately when starting/resuming

            countdownTimer = setInterval(async () => { // Made async to await saveImageMark
                remainingTime--;
                updateCountdownDisplay();

                if (remainingTime <= 0) {
                    clearInterval(countdownTimer); 
                    // Automatically mark image as sketched ONLY when timer runs out AND it's not infinite mode
                    if (currentImageIndex !== -1 && imageFiles[currentImageIndex] && displayTime !== Infinity) {
                        const finishedImagePath = imageFiles[currentImageIndex].path;
                        const finishedDuration = displayTime;
                        await window.electronAPI.saveImageMark(finishedImagePath, finishedDuration);
                        // After saving, reload marks and update playback pool (if filter is active)
                        imageMarks = await window.electronAPI.getImageMarks();
                        updatePlaybackImagePool(); // Crucial: Re-evaluate playback pool after marking
                    }
                    advanceImage(false, true); // Advance, and signal it's timer triggered for auto-marking
                }
            }, 1000); 
        }

        /**
         * Updates the countdown display text.
         */
        function updateCountdownDisplay() {
            if (displayTime === Infinity) {
                countdownElement.textContent = ''; // Empty string for infinite time
            } else if (currentTimeFormat === 'hours:minutes:seconds' && remainingTime >= 60) { // If time is 60s or more, use H:M:S
                const hours = Math.floor(remainingTime / 3600);
                const minutes = Math.floor((remainingTime % 3600) / 60);
                const seconds = remainingTime % 60;
                let display = '';
                if (hours > 0) {
                    display += `${hours.toString().padStart(2, '0')}:`;
                }
                display += `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                countdownElement.textContent = display;
            } else { // 'seconds' format OR 'hours:minutes:seconds' but < 60s
                countdownElement.textContent = `${remainingTime}`;
            }
        }

        /**
         * Applies currently set image effects.
         */
        function applyImageEffects() {
            currentImage.classList.remove('mirror-effect', 'grayscale-effect');
            if (isMirrorEnabled) currentImage.classList.add('mirror-effect');
            if (isGrayscaleEnabled) currentImage.classList.add('grayscale-effect');
            // Grid drawing is now handled in updateImageDisplay
        }

        /**
         * Updates the current image display, applying effects and calculating average background color.
         */
        function updateImageDisplay() {
            applyImageEffects(); // Apply mirror/grayscale

            // Clear previous onload/onerror to prevent multiple calls or outdated contexts
            // This is important to prevent "图片加载错误" when clearing src on stopGame()
            currentImage.onload = null;
            currentImage.onerror = null;

            // This will trigger after the image has loaded, ensuring its pixel data is available
            currentImage.onload = () => {
                if (isGridEnabled) {
                    drawGrid();
                }
                updatePreviewBackground(); // Unified background update after image loads
                updatePreviewBackgroundGrayscaleEffect(); // <--- Apply grayscale to background after it's set
            };
            // Handle cases where the image might already be cached and onload doesn't fire
            if (currentImage.complete && currentImage.naturalWidth > 0) { // Check naturalWidth for fully loaded
                currentImage.onload(); // Manually trigger if already complete
            } else {
                // If not complete, ensure initial background is set
                updatePreviewBackground();
                updatePreviewBackgroundGrayscaleEffect(); // <--- Apply grayscale to background if image not loaded yet
            }

            // Handle image loading errors (e.g., corrupted file)
            currentImage.onerror = () => {
                // Only show alert and advance if we are actually playing and expecting an image
                // Check for valid image URL patterns to avoid false positives from clearing src
                if (isPlaying && imageFiles[currentImageIndex] && currentImage.src.startsWith('file://') && currentImage.src.match(/\.(jpg|jpeg|png|gif|webp|bmp|tiff|svg)$/i)) {
                    console.error(`Error loading image: ${imageFiles[currentImageIndex]?.name || 'Unknown File Path'}: ${currentImage.src}`);
                    showCustomAlert(`无法加载图片：${imageFiles[currentImageIndex]?.name || '未知文件'}。已跳过。`, '图片加载错误');
                    // Skip to next image automatically if there's a loading error
                    // Use a short timeout to prevent rapid recursion if many images are broken
                    setTimeout(() => advanceImage(false, false), 500); 
                } else {
                    // This is likely a non-critical error (e.g., src cleared on exit, or non-image URL)
                    // console.warn(`Non-critical image loading issue or src cleared: ${currentImage.src}`); // For debugging non-critical cases
                }
            };
        }

        /**
         * Updates the enabled/disabled state of navigation buttons.
         */
        function updateNavigationButtons() {
            // Check if there's sufficient history to go back
            prevImageButton.disabled = (historyPointer <= 0);
            
            // Next button is disabled if no images are left in the filtered pool
            // OR if we are at the end of the history AND there's only one image in the current filtered pool (to prevent infinite looping with 'next' on single item)
            // OR if we are at the very last image in the filtered sequence (for sequential playback)
            let disableNext = currentPlaybackImageIndexes.length === 0;
            if (!isRandomPlayback && currentPlaybackImageIndexes.length > 0) {
                // Find the index of the current image within the *sorted* currentPlaybackImageIndexes
                const currentFilteredIndex = currentPlaybackImageIndexes.indexOf(currentImageIndex);
                if (currentFilteredIndex !== -1 && currentFilteredIndex === currentPlaybackImageIndexes.length - 1) {
                    disableNext = true; // If it's the last image in sequence, disable next
                }
            } else if (currentPlaybackImageIndexes.length === 1 && currentPlaybackImageIndexes[0] === currentImageIndex) {
                 // If there's only one image left, and it's currently displayed, disable next
                 disableNext = true;
            }


            nextImageButton.disabled = disableNext;

            // Pause/Play button should be disabled if no playable images at all.
            // If in infinite mode, it should always be enabled to allow manual pause/play.
            pausePlayButton.disabled = (currentPlaybackImageIndexes.length === 0 || (!isPlaying && displayTime !== Infinity));
        }

        /**
         * Draws the grid on the canvas.
         * The grid adapts to the actual display size of the current image.
         */
        function drawGrid() {
            const imageRect = currentImage.getBoundingClientRect();
            
            gridCanvas.width = imageRect.width;
            gridCanvas.height = imageRect.height;

            ctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); 

            if (!isGridEnabled) return; 

            ctx.lineWidth = 1;

            // Use themed grid color
            ctx.strokeStyle = hexToRgba(currentGridColorHex, gridAlpha);

            for (let x = 0; x < gridCanvas.width; x += currentGridSize) { 
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gridCanvas.height);
                ctx.stroke();
            }

            for (let y = 0; y < gridCanvas.height; y += currentGridSize) { 
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(gridCanvas.width, y); // Fix: line should go full width
                ctx.stroke();
            }
        }

        /**
         * Stops the current sketch session and returns to the main menu.
         */
        function stopGame() {
            clearInterval(countdownTimer); 
            isPlaying = false;
            isPaused = false; // Reset pause state when returning to menu
            pausePlayButton.textContent = '⏸'; // Reset button icon to Pause

            // Crucial: Clear the image source and remove event listeners FIRST
            currentImage.src = ''; 
            currentImage.onload = null; // Remove onload to prevent it firing when src is cleared
            currentImage.onerror = null; // Remove onerror to prevent false alarms

            imageDisplayArea.classList.add('hidden'); 
            controlsMenu.classList.remove('hidden'); 
            folderBrowserView.classList.add('hidden'); // Ensure image library view is also hidden
            topRightMenuButtons.classList.remove('hidden'); // Show top-right menu buttons when returning to main menu
            console.log('Sketch session stopped.');

            // Clear background from dynamic layer and apply main menu background to body
            dynamicBackgroundLayer.style.backgroundImage = 'none';
            dynamicBackgroundLayer.style.backgroundColor = 'transparent';
            dynamicBackgroundLayer.classList.remove('grayscale-active-bg'); // Ensure grayscale is off for this layer
            updateMainMenuBackground(); // Restore main menu background to body

            updateNavigationButtons(); 
            updateMarkingUI(); // Reset marking UI when returning to menu
            updatePlaybackImagePool(); // Re-evaluate button tooltips on main menu
            updateMainMenuHintText(); // Update hint text when returning to main menu

            // Show traffic lights when returning to main menu
            if (window.electronAPI) {
                window.electronAPI.setTrafficLightVisibility(true);
            }
        }

        // Main menu return button
        backToMenuButton.addEventListener('click', stopGame);

        // "Select other folder" button in image library view
        selectNewFolderFromBrowserButton.addEventListener('click', async () => {
            if (window.electronAPI) {
                // When opening folder selection dialog, default to current loaded path
                const folderPath = await window.electronAPI.openFolderDialog(currentLoadedFolderPath || undefined);
                if (folderPath) {
                    showFolderBrowserView(folderPath); // Load newly selected folder
                } else {
                    // User canceled selection, stay in image library view (keep silent)
                }
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
        });

        // "Go up folder" button in image library view
        goUpFolderButton.addEventListener('click', () => {
            const parentPath = getParentPath(currentLoadedFolderPath);
            if (parentPath) {
                showFolderBrowserView(parentPath);
            } else {
                showCustomAlert('已是顶层文件夹。', '提示');
            }
        });

        // "Back to main menu" button in image library view
        backFromBrowserToMenuButton.addEventListener('click', () => showMainMenu());

        // Pagination button event listeners
        prevPageButton.addEventListener('click', showPreviousPageOfThumbnails);
        nextPageButton.addEventListener('click', showNextPageOfThumbnails);

        // New: Library filter marked toggle button event listener
        libraryFilterMarkedToggle.addEventListener('click', async () => {
            isLibraryFilterMarkedEnabled = !isLibraryFilterMarkedEnabled;
            libraryFilterMarkedToggle.classList.toggle('active', isLibraryFilterMarkedEnabled);
            if (window.electronAPI) {
                await window.electronAPI.saveSetting('isLibraryFilterMarkedEnabled', isLibraryFilterMarkedEnabled);
            }
            // Re-render the current folder view with the new filter applied
            showFolderBrowserView(currentLoadedFolderPath);
        });

        // New: Open Sketch Log button event listener
        openSketchLogButton.addEventListener('click', async () => {
            if (window.electronAPI) {
                const result = await window.electronAPI.openLogFile();
                if (!result.success) {
                    showCustomAlert(result.message || '无法打开日志文件。', '错误');
                }
            } else {
                showCustomAlert('此功能仅在打包为桌面应用后可用。', '提示');
            }
        });

    </script>
</body>
</html>
